{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pillar: Building Blocks for Python Applications","text":"<p>Danger</p> <p>This is not the official dnslib documentation</p> <p>This is a test branch showcasing mkdocs</p>"},{"location":"#introduction","title":"Introduction","text":"<p>A library to encode/decode DNS wire-format packets.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Comprehensive DNS Record handling<ul> <li>Encoding/deciding packets in wire (binary) format.</li> <li>Encoding/decoding resource records in \"Zone\" (BIND) file format.</li> <li>Encoding/decoding packets in \"DiG\" format.</li> <li>Transparent handling of non-standard/unknown resource record types</li> <li>Ability to \"diff\" DNS recrds</li> </ul> </li> <li>Simple server framework (<code>dnslib.server</code>)<ul> <li>todo: list servers here</li> <li>Sample Servers</li> </ul> </li> <li>Useful utilities<ul> <li>DiG like client <code>python3 -m dnslib.client --help</code></li> <li>DNS proxy server <code>python3 -m dnslib.servers.proxy --help</code></li> <li>Itercepting proxy server <code>python3 -m dnslib.servers.intercept --help</code></li> </ul> </li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Follow our Quickstart Guide.</p> tldr.py<pre><code>from dnslib import DNSRecord, QTYPE, RR, A\n\n## Decode a packet\nrecord = DNSRecord.parse(bytes.fromhex(\n    \"d5ad818000010005000000000377777706676f6f676c6503636f6d0000010001c00c000500\"\n    \"0100000005000803777777016cc010c02c0001000100000005000442f95b68c02c00010001\"\n    \"00000005000442f95b63c02c0001000100000005000442f95b67c02c000100010000000500\"\n    \"0442f95b93\"\n))\n\n## Create a query\nquestion = DNSRecord.question(\"example.com\", \"A\")\n\n## Create a response to a query\nresponse = question.reply()\nresponse.add_answer(RR(\"example.com\", QTYPE.A, rdata=A(\"1.2.3.4\")\n\n## Encode a packet\nprint(\"Encoded response: {response.pack().hex()}\")\n</code></pre>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the BSD 2-Caluse License - see <code>LICENCE</code>.</p>"},{"location":"reference/dnslib/","title":"Index","text":""},{"location":"reference/dnslib/#dnslib","title":"dnslib","text":""},{"location":"reference/dnslib/#dnslib--from-version-0912-the-master-repository-for-dnslib-has-been-moved-to-github-httpsgithubcompaulcdnslib-please-update-any-links-to-the-original-bitbucket-repository-as-this-will-no-longer-be-maintained","title":"From Version 0.9.12 the master repository for dnslib has been moved to GitHub (https://github.com/paulc/dnslib). Please update any links to the original BitBucket repository as this will no longer be maintained.","text":""},{"location":"reference/dnslib/#dnslib--release-0924-2024-01-02-will-be-the-last-release-supporting-python-27-and-python-37-supporting-old-python-versions-is-increasingly-painful-and-holds-back-adoption-of-new-features-so-its-probably-time-to-move-on","title":"Release 0.9.24 (2024-01-02) will be the last release supporting Python 2.7 and Python &lt;3.7. Supporting old Python versions is increasingly painful and holds back adoption of new features so it's probably time to move on.","text":""},{"location":"reference/dnslib/#dnslib--dnslib","title":"dnslib","text":"<p>A library to encode/decode DNS wire-format packets supporting both Python 2.7 and Python 3.2+.</p> <p>The library provides:</p> <ul> <li>Support for encoding/decoding DNS packets between wire format,    python objects, and Zone/DiG textual representation (dnslib.dns)</li> </ul> <ul> <li>A server framework allowing the simple creation of custom DNS    resolvers (dnslib.server) and a number of example servers    created using this framework</li> </ul> <ul> <li>A number of utilities for testing (dnslib.client, dnslib.proxy,    dnslib.intercept)</li> </ul> <p>Python 3 support was added in Version 0.9.0 which represented a fairly major update to the library - the key changes include:</p> <ul> <li>Python 2.7/3.2+ support (the last version supporting Python 2.6    or earlier was version 0.8.3)</li> </ul> <ul> <li>The 'Bimap' interface was changed significantly to explicitly    split forward (value-&gt;text) lookups via getitem and    reverse (text-&gt;value) lookups via getattr. Applications    using the old interface will need to be updated.</li> </ul> <ul> <li>Hostnames are now returned with a trailing dot by default (in    line with RFC)</li> </ul> <ul> <li>Most object attributes are now typed in line with the record    definitions to make it harder to generate invalid packets</li> </ul> <ul> <li>Support for encoding/decoding resource records in 'Zone' (BIND)    file format</li> </ul> <ul> <li>Support for encoding/decoding packets in 'DiG' format</li> </ul> <ul> <li>Server framework allowing (in most cases) custom resolvers to    be created by just subclassing the DNSResolver class and    overriding the 'resolve' method</li> </ul> <ul> <li>A lot of fixes to error detection/handling which should make    the library much more robust to invalid/unsupported data. The    library should now either return a valid DNSRecord instance    when parsing a packet or raise DNSError (tested via fuzzing)</li> </ul> <ul> <li>Improved utilities (dnslib.client, dnslib.proxy, dnslib.intercept)</li> </ul> <ul> <li>Improvements to encoding/decoding tests including the ability    to generate test data automatically in test_decode.py (comparing    outputs against DiG)</li> </ul> <ul> <li>Ability to compare and diff DNSRecords</li> </ul>"},{"location":"reference/dnslib/#dnslib--classes","title":"Classes","text":"<p>The key DNS packet handling classes are in dnslib.dns and map to the standard DNS packet sections:</p> <ul> <li>DNSRecord - container for DNS packet. Contains:     - DNSHeader     - Question section containing zero or more DNSQuestion objects     - Answer section containing zero or more RR objects     - Authority section containing zero or more RR objects     - Additional section containing zero or more RR objects</li> <li>DNS RRs (resource records) contain an RR header and an RD object)</li> <li>Specific RD types are implemented as subclasses of RD</li> <li>DNS labels are represented by a DNSLabel class - in most cases    this handles conversion to/from textual representation however    does support arbitatry labels via a tuple of bytes objects</li> </ul>"},{"location":"reference/dnslib/#dnslib--usage","title":"Usage","text":"<p>To decode a DNS packet:</p> <pre><code>&gt;&gt;&gt; packet = bytes.fromhex('d5ad818000010005000000000377777706676f6f676c6503636f6d0000010001c00c0005000100000005000803777777016cc010c02c0001000100000005000442f95b68c02c0001000100000005000442f95b63c02c0001000100000005000442f95b67c02c0001000100000005000442f95b93')\n&gt;&gt;&gt; d = DNSRecord.parse(packet)\n&gt;&gt;&gt; d\n&lt;DNS Header: id=0xd5ad type=RESPONSE opcode=QUERY flags=RD,RA rcode='NOERROR' q=1 a=5 ns=0 ar=0&gt;\n&lt;DNS Question: 'www.google.com.' qtype=A qclass=IN&gt;\n&lt;DNS RR: 'www.google.com.' rtype=CNAME rclass=IN ttl=5 rdata='www.l.google.com.'&gt;\n&lt;DNS RR: 'www.l.google.com.' rtype=A rclass=IN ttl=5 rdata='66.249.91.104'&gt;\n&lt;DNS RR: 'www.l.google.com.' rtype=A rclass=IN ttl=5 rdata='66.249.91.99'&gt;\n&lt;DNS RR: 'www.l.google.com.' rtype=A rclass=IN ttl=5 rdata='66.249.91.103'&gt;\n&lt;DNS RR: 'www.l.google.com.' rtype=A rclass=IN ttl=5 rdata='66.249.91.147'&gt;\n</code></pre> <p>The default text representation of the DNSRecord is in zone file format:</p> <pre><code>&gt;&gt;&gt; print(d)\n;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 54701\n;; flags: qr rd ra; QUERY: 1, ANSWER: 5, AUTHORITY: 0, ADDITIONAL: 0\n;; QUESTION SECTION:\n;www.google.com.                IN      A\n;; ANSWER SECTION:\nwww.google.com.         5       IN      CNAME   www.l.google.com.\nwww.l.google.com.       5       IN      A       66.249.91.104\nwww.l.google.com.       5       IN      A       66.249.91.99\nwww.l.google.com.       5       IN      A       66.249.91.103\nwww.l.google.com.       5       IN      A       66.249.91.147\n</code></pre> <p>To create a DNS Request Packet:</p> <pre><code>&gt;&gt;&gt; d = DNSRecord.question(\"google.com\")\n</code></pre> <p>(This is equivalent to: d = DNSRecord(q=DNSQuestion(\"google.com\") )</p> <pre><code>&gt;&gt;&gt; d\n&lt;DNS Header: id=... type=QUERY opcode=QUERY flags=RD rcode='NOERROR' q=1 a=0 ns=0 ar=0&gt;\n&lt;DNS Question: 'google.com.' qtype=A qclass=IN&gt;\n\n&gt;&gt;&gt; str(DNSRecord.parse(d.pack())) == str(d)\nTrue\n\n&gt;&gt;&gt; print(d)\n;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: ...\n;; flags: rd; QUERY: 1, ANSWER: 0, AUTHORITY: 0, ADDITIONAL: 0\n;; QUESTION SECTION:\n;google.com.                    IN      A\n\n&gt;&gt;&gt; d = DNSRecord.question(\"google.com\",\"MX\")\n</code></pre> <p>(This is equivalent to: d = DNSRecord(q=DNSQuestion(\"google.com\",QTYPE.MX) )</p> <pre><code>&gt;&gt;&gt; str(DNSRecord.parse(d.pack())) == str(d)\nTrue\n\n&gt;&gt;&gt; print(d)\n;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: ...\n;; flags: rd; QUERY: 1, ANSWER: 0, AUTHORITY: 0, ADDITIONAL: 0\n;; QUESTION SECTION:\n;google.com.                    IN      MX\n</code></pre> <p>To create a DNS Response Packet:</p> <pre><code>&gt;&gt;&gt; d = DNSRecord(DNSHeader(qr=1,aa=1,ra=1),\n...               q=DNSQuestion(\"abc.com\"),\n...               a=RR(\"abc.com\",rdata=A(\"1.2.3.4\")))\n&gt;&gt;&gt; d\n&lt;DNS Header: id=... type=RESPONSE opcode=QUERY flags=AA,RD,RA rcode='NOERROR' q=1 a=1 ns=0 ar=0&gt;\n&lt;DNS Question: 'abc.com.' qtype=A qclass=IN&gt;\n&lt;DNS RR: 'abc.com.' rtype=A rclass=IN ttl=0 rdata='1.2.3.4'&gt;\n&gt;&gt;&gt; str(DNSRecord.parse(d.pack())) == str(d)\nTrue\n\n&gt;&gt;&gt; print(d)\n;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: ...\n;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0\n;; QUESTION SECTION:\n;abc.com.                       IN      A\n;; ANSWER SECTION:\nabc.com.                0       IN      A       1.2.3.4\n</code></pre> <p>It is also possible to create RRs from a string in zone file format</p> <pre><code>&gt;&gt;&gt; RR.fromZone(\"abc.com IN A 1.2.3.4\")\n[&lt;DNS RR: 'abc.com.' rtype=A rclass=IN ttl=0 rdata='1.2.3.4'&gt;]\n\n(Note: this produces a list of RRs which should be unpacked if being\npassed to add_answer/add_auth/add_ar etc)\n\n&gt;&gt;&gt; q = DNSRecord.question(\"abc.com\")\n&gt;&gt;&gt; a = q.reply()\n&gt;&gt;&gt; a.add_answer(*RR.fromZone(\"abc.com 60 A 1.2.3.4\"))\n&gt;&gt;&gt; print(a)\n;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: ...\n;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0\n;; QUESTION SECTION:\n;abc.com.                       IN      A\n;; ANSWER SECTION:\nabc.com.                60      IN      A       1.2.3.4\n</code></pre> <p>The zone file can contain multiple entries and supports most of the normal format defined in RFC1035 (specifically not $INCLUDE)</p> <pre><code>&gt;&gt;&gt; z = '''\n...         $TTL 300\n...         $ORIGIN abc.com\n...\n...         @       IN      MX      10  mail.abc.com.\n...         www     IN      A       1.2.3.4\n...                 IN      TXT     \"Some Text\"\n...         mail    IN      CNAME   www.abc.com.\n... '''\n&gt;&gt;&gt; for rr in RR.fromZone(textwrap.dedent(z)):\n...     print(rr)\nabc.com.                300     IN      MX      10 mail.abc.com.\nwww.abc.com.            300     IN      A       1.2.3.4\nwww.abc.com.            300     IN      TXT     \"Some Text\"\nmail.abc.com.           300     IN      CNAME   www.abc.com.\n</code></pre> <p>To create a skeleton reply to a DNS query:</p> <pre><code>&gt;&gt;&gt; q = DNSRecord(q=DNSQuestion(\"abc.com\",QTYPE.ANY))\n&gt;&gt;&gt; a = q.reply()\n&gt;&gt;&gt; a.add_answer(RR(\"abc.com\",QTYPE.A,rdata=A(\"1.2.3.4\"),ttl=60))\n&gt;&gt;&gt; str(DNSRecord.parse(a.pack())) == str(a)\nTrue\n&gt;&gt;&gt; print(a)\n;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: ...\n;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0\n;; QUESTION SECTION:\n;abc.com.                       IN      ANY\n;; ANSWER SECTION:\nabc.com.                60      IN      A       1.2.3.4\n</code></pre> <p>Add additional RRs:</p> <pre><code>&gt;&gt;&gt; a.add_answer(RR(\"xxx.abc.com\",QTYPE.A,rdata=A(\"1.2.3.4\")))\n&gt;&gt;&gt; a.add_answer(RR(\"xxx.abc.com\",QTYPE.AAAA,rdata=AAAA(\"1234:5678::1\")))\n&gt;&gt;&gt; str(DNSRecord.parse(a.pack())) == str(a)\nTrue\n&gt;&gt;&gt; print(a)\n;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: ...\n;; flags: qr aa rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 0\n;; QUESTION SECTION:\n;abc.com.                       IN      ANY\n;; ANSWER SECTION:\nabc.com.                60      IN      A       1.2.3.4\nxxx.abc.com.            0       IN      A       1.2.3.4\nxxx.abc.com.            0       IN      AAAA    1234:5678::1\n</code></pre> <p>It is also possible to create a reply from a string in zone file format:</p> <pre><code>&gt;&gt;&gt; q = DNSRecord(q=DNSQuestion(\"abc.com\",QTYPE.ANY))\n&gt;&gt;&gt; a = q.replyZone(\"abc.com 60 IN CNAME xxx.abc.com\")\n&gt;&gt;&gt; print(a)\n;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: ...\n;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0\n;; QUESTION SECTION:\n;abc.com.                       IN      ANY\n;; ANSWER SECTION:\nabc.com.                60      IN      CNAME   xxx.abc.com.\n\n&gt;&gt;&gt; str(DNSRecord.parse(a.pack())) == str(a)\nTrue\n\n&gt;&gt;&gt; q = DNSRecord(q=DNSQuestion(\"abc.com\",QTYPE.ANY))\n&gt;&gt;&gt; a = q.replyZone(textwrap.dedent(z))\n&gt;&gt;&gt; print(a)\n;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: ...\n;; flags: qr aa rd ra; QUERY: 1, ANSWER: 4, AUTHORITY: 0, ADDITIONAL: 0\n;; QUESTION SECTION:\n;abc.com.                       IN      ANY\n;; ANSWER SECTION:\nabc.com.                300     IN      MX      10 mail.abc.com.\nwww.abc.com.            300     IN      A       1.2.3.4\nwww.abc.com.            300     IN      TXT     \"Some Text\"\nmail.abc.com.           300     IN      CNAME   www.abc.com.\n</code></pre> <p>To send a DNSSEC request (EDNS OPT record with DO flag &amp; header AD flag):</p> <pre><code>&gt;&gt;&gt; q = DNSRecord(q=DNSQuestion(\"abc.com\",QTYPE.A))\n&gt;&gt;&gt; q.add_ar(EDNS0(flags=\"do\",udp_len=4096))\n&gt;&gt;&gt; q.header.ad = 1\n&gt;&gt;&gt; print(q)\n;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: ...\n;; flags: rd ad; QUERY: 1, ANSWER: 0, AUTHORITY: 0, ADDITIONAL: 1\n;; QUESTION SECTION:\n;abc.com.                       IN      A\n;; ADDITIONAL SECTION:\n;; OPT PSEUDOSECTION\n; EDNS: version: 0, flags: do; udp: 4096\n</code></pre> <p>Note that when using the library you should always validate the received TXID </p> <pre><code>q = DNSRecord.question(\"abc.com\")\na_pkt = q.send(address,port,tcp=args.tcp)\na = DNSRecord.parse(a_pkt)\nif q.header.id != a.header.id:\n    raise DNSError('Response transaction id does not match query transaction id')\n</code></pre> <p>The library also includes a simple framework for generating custom DNS resolvers in dnslib.server (see module docs). In most cases this just requires implementing a custom 'resolve' method which receives a question object and returns a response.</p> <p>A number of sample resolvers are provided as examples (see CLI --help):</p> <ul> <li>dnslib.fixedresolver    - Respond to all requests with fixed response</li> <li>dnslib.zoneresolver     - Respond from Zone file</li> <li>dnslib.shellresolver    - Call shell script to generate response</li> </ul> <p>The library includes a number of client utilities:</p> <ul> <li>DiG like client library<pre><code>  # python -m dnslib.client --help\n</code></pre> </li> </ul> <ul> <li>DNS Proxy Server<pre><code>  # python -m dnslib.proxy --help\n</code></pre> </li> </ul> <ul> <li>Intercepting DNS Proxy Server (replace proxy responses for specified domains)<pre><code>  # python -m dnslib.intercept --help\n</code></pre> </li> </ul>"},{"location":"reference/dnslib/#dnslib--changelog","title":"Changelog:","text":"<pre><code> *   0.1     2010-09-19  Initial Release\n *   0.2     2010-09-22  Minor fixes\n *   0.3     2010-10-02  Add DNSLabel class to support arbitrary labels (embedded '.')\n *   0.4     2012-02-26  Merge with dbslib-circuits\n *   0.5     2012-09-13  Add support for RFC2136 DDNS updates\n                         Patch provided by Wesley Shields &lt;wxs@FreeBSD.org&gt; - thanks\n *   0.6     2012-10-20  Basic AAAA support\n *   0.7     2012-10-20  Add initial EDNS0 support (untested)\n *   0.8     2012-11-04  Add support for NAPTR, Authority RR and additional RR\n                         Patch provided by Stefan Andersson (https://bitbucket.org/norox) - thanks\n *   0.8.1   2012-11-05  Added NAPTR test case and fixed logic error\n                         Patch provided by Stefan Andersson (https://bitbucket.org/norox) - thanks\n *   0.8.2   2012-11-11  Patch to fix IPv6 formatting\n                         Patch provided by Torbjorn Lonnemark (https://bitbucket.org/tobbezz) - thanks\n *   0.8.3   2013-04-27  Don't parse rdata if rdlength is 0\n                         Patch provided by Wesley Shields &lt;wxs@FreeBSD.org&gt; - thanks\n *   0.9.0   2014-05-05  Major update including Py3 support (see docs)\n *   0.9.1   2014-05-05  Minor fixes\n *   0.9.2   2014-08-26  Fix Bimap handling of unknown mappings to avoid exception in printing\n                         Add typed attributes to classes\n                         Misc fixes from James Mills - thanks\n *   0.9.3   2014-08-26  Workaround for argparse bug which raises AssertionError if [] is\n                         present in option text (really?)\n *   0.9.4   2015-04-10  Fix to support multiple strings in TXT record\n                         Patch provided by James Cherry (https://bitbucket.org/james_cherry) - thanks\n                         NOTE: For consistency this patch changes the 'repr' output for\n                               TXT records to always be quoted\n *   0.9.5   2015-10-27  Add threading &amp; timeout handling to DNSServer\n *   0.9.6   2015-10-28  Replace strftime in RRSIG formatting to avoid possible locale issues\n                         Identified by Bryan Everly - thanks\n *   0.9.7   2017-01-15  Sort out CAA/TYPE257 DiG parsing mismatch\n *   0.9.8   2019-02-25  Force DNSKEY key to be bytes object\n                         Catch Bimap __wrapped__ attr (used by inspect module in 3.7)\n *   0.9.9   2019-03-19  Add support for DNSSEC flag getters/setters (from &lt;raul@dinosec.com&gt; - thanks)\n                         Added --dnssec flags to dnslib.client &amp; dnslib.test_decode (sets EDNS0 DO flag)\n                         Added EDNS0 support to dnslib.digparser\n *   0.9.10  2019-03-24  Fixes to DNSSEC support\n                         Add NSEC RR support\n                         Add --dnssec flag to dnslib.client &amp; dnslib.test_decode\n                         Quote/unquote non-printable characters in DNS labels\n                         Update test data\n                         (Thanks to &lt;raul@dinosec.com&gt; for help)\n *   0.9.11  2019-12-17  Encode NOTIFY Opcode (Issue #26)\n *   0.9.12  2019-12-17  Transition master repository to Github (Bitbucket shutting down hg)\n *   0.9.13  2020-06-01  Handle truncated requests in server.py (Issue #9)\n                         Replace thred.isAlive with thread.is_alive (Deprecated in Py3.9)\n                         Merged Pull Request #4 (Extra options for intercept.py) - thanks to @nolanl\n *   0.9.14  2020-06-09  Merged Pull Request #10 (Return doctest status via exit code)\n                         Thanks to @mgorny\n *   0.9.15  2021-05-07  DNSServer fixes - support IPv6 (from Pull Request #21) - thanks to @mikma\n                                         - deamon threads (Pull Request #19) - thanks to @wojons\n                         Add unsupported RR types (Issue #27)\n *   0.9.16  2021-05-07  Merge pull request #23 from Tugzrida/patch-1\n                            Add support for all RR types to NSEC type bitmap\n                         Merge pull request #17 from sunds/issue_16\n                            Issue 16: uncaught exceptions leak open sockets\n *   0.9.18  2022-01-09  Validate TXID in client.py (Issue #30 - thanks to @daniel4x)\n *   0.9.19  2022-01-09  Allow custom log function (logf) in  DNSLogger\n                            (Issue #31 - thanks to @DmitryFrolovTri)\n *   0.9.20  2022-07-17  Fix DeprecationWarnings about invalid escape sequences\n                            (Pull-Request #39 - thanks to @brianmaissy)\n                         Make DNSLabel matchSuffix and stripSuffix case-insensitive\n                            (Pull-Request #37 - thanks to @NiKiZe)\n                         Add support for HTTPS RR\n                            (Pull-Request #35 - thanks to @jkl-caliber)\n                         Fix display of non-printable characters in TXT records\n                            (Issue #32 - thanks to @sbv-csis)\n                         Add --strip-aaaa option to dnslib.proxy\n *   0.9.21  2022-09-19  Minor clean-up / add wheels to distro\n *   0.9.22  2022-09027  Issue #43 (0.9.21 Raises TypeError instead of DNSError when failing to parse HTTPS records)\n                         Note that we just fix the exception - there still seems to be a problem with parsing HTTPS records\n                         (Thanks to @robinlandstrom)\n *   0.9.23  2022-10-28  Issue #43: HTTPS reads after RD end (thanks to @robinlandstrom for pull request)\n                         Issue #45: Dnslib fails to handle unknown RR types in NSEC RD type bitmap\n                            Bimap now supports a function to map unknown types which we use to\n                            dynamically map from rtype &lt;-&gt; TYPExxxx for unknown record types\n                            RR zone representation updated to match RFC3597\n                         Pull Request #47: Add support for DS, SSHFP, and TLSA records (thanks to @rmbolger)\n *   0.9.24  2024-01-02  Merge multiple PRs\n                            #49 - Generate README.md (via symlink)\n                            #51 - Update Github CI checkout &amp; setup-python actions (and remove Python 2.7 CI support)\n                                  (thanks to @SpencerIsGiddy)\n                            #54 - Support for RP records (thanks to @ryan-gang)\n                            #57 - Support for LOC records (thanks to @valentinesd)\n                         (Note that this will be the last release supporting Python 2.7 and Python &lt;3.7)\n</code></pre>"},{"location":"reference/dnslib/#dnslib--license","title":"License:","text":"<p>BSD</p>"},{"location":"reference/dnslib/#dnslib--author","title":"Author:","text":"<ul> <li>PaulC</li> </ul>"},{"location":"reference/dnslib/#dnslib--master-repositoryissues","title":"Master Repository/Issues:","text":"<ul> <li>https://github.com/paulc/dnslib</li> </ul> <p>(Note: https://bitbucket.org/paulc/dnslib has been deprecated and will not be updated)</p>"},{"location":"reference/dnslib/bimap/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> bimap","text":""},{"location":"reference/dnslib/bimap/#dnslib.bimap","title":"dnslib.bimap","text":""},{"location":"reference/dnslib/bimap/#dnslib.bimap.Bimap","title":"Bimap","text":"<pre><code>Bimap(\n    name: str,\n    forward: Dict[int, str],\n    error: Union[\n        ErrorCallable, Type[Exception]\n    ] = AttributeError,\n)\n</code></pre> <p>Bi-directional mapping between numerical codes and text.</p> <p>The class provides:</p> <ul> <li>A 'forward' map (code-&gt;text) which is accessed through     <code>__getitem__</code> (<code>bimap[code]</code>)</li> <li>A 'reverse' map (code&gt;value) which is accessed through     <code>__getattr__</code> (<code>bimap.text</code>)</li> <li>A 'get' method which does a forward lookup (code-&gt;text)     and returns a textual version of code if there is no     explicit mapping (or default provided)</li> </ul> <pre><code>&gt;&gt;&gt; class TestError(Exception):\n...     pass\n\n&gt;&gt;&gt; TEST = Bimap('TEST',{1:'A', 2:'B', 3:'C'},TestError)\n&gt;&gt;&gt; TEST[1]\n'A'\n&gt;&gt;&gt; TEST.A\n1\n&gt;&gt;&gt; TEST.X\nTraceback (most recent call last):\n...\nTestError: TEST: Invalid reverse lookup: [X]\n&gt;&gt;&gt; TEST[99]\nTraceback (most recent call last):\n...\nTestError: TEST: Invalid forward lookup: [99]\n&gt;&gt;&gt; TEST.get(99)\n'99'\n\n# Test with callable error\n&gt;&gt;&gt; def _error(name,key):\n...     if isinstance(key, int):\n...         return f\"TEST{key}\"\n...     if key.startswith(\"TEST\"):\n...         try:\n...             return int(key.removeprefix(\"TEST\"))\n...         except:\n...             pass\n...     raise TestError(f\"{name}: Invalid lookup: [{key!r}]\")\n&gt;&gt;&gt; TEST2 = Bimap('TEST2',{1:'A', 2:'B', 3:'C'},_error)\n&gt;&gt;&gt; TEST2[1]\n'A'\n&gt;&gt;&gt; TEST2[9999]\n'TEST9999'\n&gt;&gt;&gt; TEST2['abcd']\nTraceback (most recent call last):\n...\nTestError: TEST2: Invalid lookup: ['abcd']\n&gt;&gt;&gt; TEST2.A\n1\n&gt;&gt;&gt; TEST2.TEST9999\n9999\n&gt;&gt;&gt; TEST2.X\nTraceback (most recent call last):\n...\nTestError: TEST2: Invalid lookup: ['X']\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of this Bimap (used in exceptions)</p> required <code>forward</code> <code>Dict[int, str]</code> <p>mapping from code (numeric) to text</p> required <code>error</code> <code>Union[ErrorCallable, Type[Exception]]</code> <p>Error type to raise if key not found or callable which either generates mapping or raises an error</p> <code>AttributeError</code>"},{"location":"reference/dnslib/bimap/#dnslib.bimap.Bimap.get","title":"get","text":"<pre><code>get(key: int, default: Optional[str] = None) -&gt; str\n</code></pre> <p>Get string for given numerical key</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>int</code> required <code>default</code> <code>Optional[str]</code> <p>default value to return if key is missing</p> <code>None</code>"},{"location":"reference/dnslib/bit/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> bit","text":""},{"location":"reference/dnslib/bit/#dnslib.bit","title":"dnslib.bit","text":"<p>Basic bit mainpulation utilities</p>"},{"location":"reference/dnslib/bit/#dnslib.bit.binary","title":"binary","text":"<pre><code>binary(\n    n: int, count: int = 16, reverse: bool = False\n) -&gt; str\n</code></pre> <p>Convert an integer to a binary string</p> <p>(only difference from built-in <code>bin</code> is that this function returns a fixed width string and can optionally be reversed</p> <pre><code>&gt;&gt;&gt; binary(6789)\n'0001101010000101'\n&gt;&gt;&gt; binary(6789,8)\n'10000101'\n&gt;&gt;&gt; binary(6789,reverse=True)\n'1010000101011000'\n</code></pre>"},{"location":"reference/dnslib/bit/#dnslib.bit.get_bits","title":"get_bits","text":"<pre><code>get_bits(data: int, offset: int, bits: int = 1) -&gt; int\n</code></pre> <p>Get specified bits from integer</p> <pre><code>&gt;&gt;&gt; bin(get_bits(0b0011100,2))\n'0b1'\n&gt;&gt;&gt; bin(get_bits(0b0011100,0,4))\n'0b1100'\n</code></pre>"},{"location":"reference/dnslib/bit/#dnslib.bit.hexdump","title":"hexdump","text":"<pre><code>hexdump(\n    src: bytes, length: int = 16, prefix: str = \"\"\n) -&gt; str\n</code></pre> <p>Format a pretty hexdump of a byte string</p> <pre><code>&gt;&gt;&gt; print(hexdump(b\"abcd\" * 4))\n0000  61 62 63 64 61 62 63 64  61 62 63 64 61 62 63 64  abcdabcd abcdabcd\n\n&gt;&gt;&gt; print(hexdump(bytearray(range(48))))\n0000  00 01 02 03 04 05 06 07  08 09 0a 0b 0c 0d 0e 0f  ........ ........\n0010  10 11 12 13 14 15 16 17  18 19 1a 1b 1c 1d 1e 1f  ........ ........\n0020  20 21 22 23 24 25 26 27  28 29 2a 2b 2c 2d 2e 2f   !\"#$%&amp;' ()*+,-./\n</code></pre>"},{"location":"reference/dnslib/bit/#dnslib.bit.set_bits","title":"set_bits","text":"<pre><code>set_bits(\n    data: int, value: int, offset: int, bits: int = 1\n) -&gt; int\n</code></pre> <p>Set specified bits in integer</p> <pre><code>&gt;&gt;&gt; bin(set_bits(0,0b1010,0,4))\n'0b1010'\n&gt;&gt;&gt; bin(set_bits(0,0b1010,3,4))\n'0b1010000'\n</code></pre>"},{"location":"reference/dnslib/buffer/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> buffer","text":""},{"location":"reference/dnslib/buffer/#dnslib.buffer","title":"dnslib.buffer","text":""},{"location":"reference/dnslib/buffer/#dnslib.buffer.Buffer","title":"Buffer","text":"<pre><code>Buffer(data: bytes = b'')\n</code></pre> <p>A simple data buffer - supports packing/unpacking in struct format</p> <pre><code>&gt;&gt;&gt; b = Buffer()\n&gt;&gt;&gt; b.pack(\"!BHI\",1,2,3)\n&gt;&gt;&gt; b.offset\n7\n&gt;&gt;&gt; b.append(b\"0123456789\")\n&gt;&gt;&gt; b.offset\n17\n&gt;&gt;&gt; b.hex()\n'0100020000000330313233343536373839'\n&gt;&gt;&gt; b.offset = 0\n&gt;&gt;&gt; b.unpack(\"!BHI\")\n(1, 2, 3)\n&gt;&gt;&gt; bytearray(b.get(5))\nbytearray(b'01234')\n&gt;&gt;&gt; bytearray(b.get(5))\nbytearray(b'56789')\n&gt;&gt;&gt; b.update(7,\"2s\",b\"xx\")\n&gt;&gt;&gt; b.offset = 7\n&gt;&gt;&gt; bytearray(b.get(5))\nbytearray(b'xx234')\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>initial data</p> <code>b''</code>"},{"location":"reference/dnslib/buffer/#dnslib.buffer.Buffer.remaining","title":"remaining  <code>property</code>","text":"<pre><code>remaining: int\n</code></pre> <p>Number of bytes from the current offset until the end of the buffer</p>"},{"location":"reference/dnslib/buffer/#dnslib.buffer.Buffer.append","title":"append","text":"<pre><code>append(s: bytes) -&gt; None\n</code></pre> <p>Append data to end of the buffer and increment offset</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>bytes</code> <p>data to append</p> required"},{"location":"reference/dnslib/buffer/#dnslib.buffer.Buffer.append_with_length","title":"append_with_length","text":"<pre><code>append_with_length(length_format: str, s: bytes) -&gt; None\n</code></pre> <p>Append length prefixed data to the buffer.</p> <p>Is a shortcut to calling:</p> <pre><code>buffer.pack(\"H\", len(data))\nbuffer.append(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>length_format</code> <code>str</code> <p>struct format of the length</p> required <code>s</code> <code>bytes</code> <p>data to append</p> required <p>New in 1.0</p>"},{"location":"reference/dnslib/buffer/#dnslib.buffer.Buffer.get","title":"get","text":"<pre><code>get(length: int) -&gt; bytes\n</code></pre> <p>Get bytes from the buffer starting at the current offset and increment offset</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>number of bytes to get</p> required <p>Raises:</p> Type Description <code>BufferError</code> <p>if length is greater than remaining bytes.</p>"},{"location":"reference/dnslib/buffer/#dnslib.buffer.Buffer.get_with_length","title":"get_with_length","text":"<pre><code>get_with_length(fmt: str) -&gt; bytes\n</code></pre> <p>Get bytes from the buffer using a length prefix</p> <p>This is a shortcut to:</p> <pre><code>data = buffer.get(buffer.unpack_one(\"!H\"))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>fmt</code> <code>str</code> <p>struct format of length prefix, must return a single value.</p> required"},{"location":"reference/dnslib/buffer/#dnslib.buffer.Buffer.hex","title":"hex","text":"<pre><code>hex() -&gt; str\n</code></pre> <p>Return data as hex string</p>"},{"location":"reference/dnslib/buffer/#dnslib.buffer.Buffer.pack","title":"pack","text":"<pre><code>pack(fmt: str, *args) -&gt; None\n</code></pre> <p>Pack a struct and append it to the buffer</p> <p>Parameters:</p> Name Type Description Default <code>fmt</code> <code>str</code> <p>struct format</p> required <code>args</code> <p>data to pack into the struct</p> <code>()</code>"},{"location":"reference/dnslib/buffer/#dnslib.buffer.Buffer.unpack","title":"unpack","text":"<pre><code>unpack(fmt: str) -&gt; Tuple\n</code></pre> <p>Unpack a struct from the current offset and increment offset</p> <p>Parameters:</p> Name Type Description Default <code>fmt</code> <code>str</code> <p>struct format to unpack</p> required <p>Raises:</p> Type Description <code>BufferError</code> <p>if could not unpack struct</p>"},{"location":"reference/dnslib/buffer/#dnslib.buffer.Buffer.unpack_one","title":"unpack_one","text":"<pre><code>unpack_one(fmt: str) -&gt; Any\n</code></pre> <p>Unpack a single value from the current offset and increment offset</p> <p>This is this a shortcut to using <code>unpack</code> with a struct that returns a <code>tuple</code> of length where you then need to extract the single value.</p> <p>Parameters:</p> Name Type Description Default <code>fmt</code> <code>str</code> <p>struct format to unpack</p> required <p>New in 1.0</p>"},{"location":"reference/dnslib/buffer/#dnslib.buffer.Buffer.update","title":"update","text":"<pre><code>update(ptr: int, fmt: str, *args: Any) -&gt; None\n</code></pre> <p>Modify data at offset <code>ptr</code></p> <p>Parameters:</p> Name Type Description Default <code>ptr</code> <code>int</code> <p>the offset the start the modification at</p> required <code>fmt</code> <code>str</code> <p>struct format</p> required <code>args</code> <code>Any</code> <p>data to pack into struct format</p> <code>()</code>"},{"location":"reference/dnslib/client/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> client","text":""},{"location":"reference/dnslib/client/#dnslib.client","title":"dnslib.client","text":"<p>DNS Client - DiG-like CLI utility.</p> <p>Mostly useful for testing. Can optionally compare results from two nameservers (--diff) or compare results against DiG (--dig).</p> <p>Usage: python -m dnslib.client [options|--help]</p> <p>See --help for usage.</p>"},{"location":"reference/dnslib/digparser/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> digparser","text":""},{"location":"reference/dnslib/digparser/#dnslib.digparser","title":"dnslib.digparser","text":""},{"location":"reference/dnslib/digparser/#dnslib.digparser--digparser","title":"digparser","text":"<p>Encode/decode DNS packets from DiG textual representation. Parses question (if present: +qr flag) &amp; answer sections and returns list of DNSRecord objects.</p> <p>Unsupported RR types are skipped (this is different from the packet parser which will store and encode the RDATA as a binary blob)</p> <pre><code>&gt;&gt;&gt; dig = os.path.join(os.path.dirname(__file__),\"test\",\"dig\",\"google.com-A.dig\")\n&gt;&gt;&gt; with open(dig) as f:\n...     l = DigParser(f)\n...     for record in l:\n...         print('---')\n...         print(repr(record))\n---\n&lt;DNS Header: id=0x5c9a type=QUERY opcode=QUERY flags=RD rcode='NOERROR' q=1 a=0 ns=0 ar=0&gt;\n&lt;DNS Question: 'google.com.' qtype=A qclass=IN&gt;\n---\n&lt;DNS Header: id=0x5c9a type=RESPONSE opcode=QUERY flags=RD,RA rcode='NOERROR' q=1 a=16 ns=0 ar=0&gt;\n&lt;DNS Question: 'google.com.' qtype=A qclass=IN&gt;\n&lt;DNS RR: 'google.com.' rtype=A rclass=IN ttl=299 rdata='62.252.169.183'&gt;\n&lt;DNS RR: 'google.com.' rtype=A rclass=IN ttl=299 rdata='62.252.169.152'&gt;\n&lt;DNS RR: 'google.com.' rtype=A rclass=IN ttl=299 rdata='62.252.169.172'&gt;\n&lt;DNS RR: 'google.com.' rtype=A rclass=IN ttl=299 rdata='62.252.169.177'&gt;\n&lt;DNS RR: 'google.com.' rtype=A rclass=IN ttl=299 rdata='62.252.169.157'&gt;\n&lt;DNS RR: 'google.com.' rtype=A rclass=IN ttl=299 rdata='62.252.169.153'&gt;\n&lt;DNS RR: 'google.com.' rtype=A rclass=IN ttl=299 rdata='62.252.169.182'&gt;\n&lt;DNS RR: 'google.com.' rtype=A rclass=IN ttl=299 rdata='62.252.169.168'&gt;\n&lt;DNS RR: 'google.com.' rtype=A rclass=IN ttl=299 rdata='62.252.169.178'&gt;\n&lt;DNS RR: 'google.com.' rtype=A rclass=IN ttl=299 rdata='62.252.169.162'&gt;\n&lt;DNS RR: 'google.com.' rtype=A rclass=IN ttl=299 rdata='62.252.169.187'&gt;\n&lt;DNS RR: 'google.com.' rtype=A rclass=IN ttl=299 rdata='62.252.169.167'&gt;\n&lt;DNS RR: 'google.com.' rtype=A rclass=IN ttl=299 rdata='62.252.169.148'&gt;\n&lt;DNS RR: 'google.com.' rtype=A rclass=IN ttl=299 rdata='62.252.169.173'&gt;\n&lt;DNS RR: 'google.com.' rtype=A rclass=IN ttl=299 rdata='62.252.169.158'&gt;\n&lt;DNS RR: 'google.com.' rtype=A rclass=IN ttl=299 rdata='62.252.169.163'&gt;\n\n&gt;&gt;&gt; dig = os.path.join(os.path.dirname(__file__),\"test\",\"dig\",\"google.com-ANY.dig\")\n&gt;&gt;&gt; with open(dig) as f:\n...     l = DigParser(f)\n...     for record in l:\n...         print('---')\n...         print(repr(record))\n---\n&lt;DNS Header: id=0xb294 type=QUERY opcode=QUERY flags=RD rcode='NOERROR' q=1 a=0 ns=0 ar=0&gt;\n&lt;DNS Question: 'google.com.' qtype=ANY qclass=IN&gt;\n---\n&lt;DNS Header: id=0xb294 type=RESPONSE opcode=QUERY flags=RD,RA rcode='NOERROR' q=1 a=14 ns=0 ar=0&gt;\n&lt;DNS Question: 'google.com.' qtype=ANY qclass=IN&gt;\n&lt;DNS RR: 'google.com.' rtype=A rclass=IN ttl=299 rdata='216.58.212.110'&gt;\n&lt;DNS RR: 'google.com.' rtype=AAAA rclass=IN ttl=299 rdata='2a00:1450:4009:807::200e'&gt;\n&lt;DNS RR: 'google.com.' rtype=CAA rclass=IN ttl=86399 rdata='0 issue \"symantec.com\"'&gt;\n&lt;DNS RR: 'google.com.' rtype=MX rclass=IN ttl=599 rdata='40 alt3.aspmx.l.google.com.'&gt;\n&lt;DNS RR: 'google.com.' rtype=MX rclass=IN ttl=599 rdata='10 aspmx.l.google.com.'&gt;\n&lt;DNS RR: 'google.com.' rtype=NS rclass=IN ttl=86399 rdata='ns2.google.com.'&gt;\n&lt;DNS RR: 'google.com.' rtype=MX rclass=IN ttl=599 rdata='20 alt1.aspmx.l.google.com.'&gt;\n&lt;DNS RR: 'google.com.' rtype=SOA rclass=IN ttl=59 rdata='ns2.google.com. dns-admin.google.com. 144578247 900 900 1800 60'&gt;\n&lt;DNS RR: 'google.com.' rtype=NS rclass=IN ttl=86399 rdata='ns1.google.com.'&gt;\n&lt;DNS RR: 'google.com.' rtype=NS rclass=IN ttl=86399 rdata='ns4.google.com.'&gt;\n&lt;DNS RR: 'google.com.' rtype=NS rclass=IN ttl=86399 rdata='ns3.google.com.'&gt;\n&lt;DNS RR: 'google.com.' rtype=MX rclass=IN ttl=599 rdata='50 alt4.aspmx.l.google.com.'&gt;\n&lt;DNS RR: 'google.com.' rtype=TXT rclass=IN ttl=3599 rdata='\"v=spf1 include:_spf.google.com ~all\"'&gt;\n&lt;DNS RR: 'google.com.' rtype=MX rclass=IN ttl=599 rdata='30 alt2.aspmx.l.google.com.'&gt;\n</code></pre>"},{"location":"reference/dnslib/digparser/#dnslib.digparser.DigParser","title":"DigParser","text":"<pre><code>DigParser(dig, debug=False)\n</code></pre> <p>Parser for DiG output</p>"},{"location":"reference/dnslib/dns/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> dns","text":""},{"location":"reference/dnslib/dns/#dnslib.dns","title":"dnslib.dns","text":"<p>DNS - main dnslib module</p> <p>Contains core DNS packet handling code</p>"},{"location":"reference/dnslib/dns/#dnslib.dns.CLASS","title":"CLASS  <code>module-attribute</code>","text":"<pre><code>CLASS = Bimap(\n    \"CLASS\",\n    {\n        1: \"IN\",\n        2: \"CS\",\n        3: \"CH\",\n        4: \"Hesiod\",\n        254: \"None\",\n        255: \"*\",\n    },\n    DNSError,\n)\n</code></pre> <p>CLASS <code>Bimap</code> - allows bi-directional mapping between integer and text representations</p>"},{"location":"reference/dnslib/dns/#dnslib.dns.OPCODE","title":"OPCODE  <code>module-attribute</code>","text":"<pre><code>OPCODE = Bimap(\n    \"OPCODE\",\n    {\n        0: \"QUERY\",\n        1: \"IQUERY\",\n        2: \"STATUS\",\n        4: \"NOTIFY\",\n        5: \"UPDATE\",\n    },\n    DNSError,\n)\n</code></pre> <p>OPCODE <code>Bimap</code> - allows bi-directional mapping between integer and text representations</p>"},{"location":"reference/dnslib/dns/#dnslib.dns.QR","title":"QR  <code>module-attribute</code>","text":"<pre><code>QR = Bimap('QR', {0: 'QUERY', 1: 'RESPONSE'}, DNSError)\n</code></pre> <p>QR <code>Bimap</code> - allows bi-directional mapping between integer and text representations</p>"},{"location":"reference/dnslib/dns/#dnslib.dns.QTYPE","title":"QTYPE  <code>module-attribute</code>","text":"<pre><code>QTYPE = Bimap(\n    \"QTYPE\",\n    {\n        1: \"A\",\n        2: \"NS\",\n        5: \"CNAME\",\n        6: \"SOA\",\n        10: \"NULL\",\n        12: \"PTR\",\n        13: \"HINFO\",\n        15: \"MX\",\n        16: \"TXT\",\n        17: \"RP\",\n        18: \"AFSDB\",\n        24: \"SIG\",\n        25: \"KEY\",\n        28: \"AAAA\",\n        29: \"LOC\",\n        33: \"SRV\",\n        35: \"NAPTR\",\n        36: \"KX\",\n        37: \"CERT\",\n        38: \"A6\",\n        39: \"DNAME\",\n        41: \"OPT\",\n        42: \"APL\",\n        43: \"DS\",\n        44: \"SSHFP\",\n        45: \"IPSECKEY\",\n        46: \"RRSIG\",\n        47: \"NSEC\",\n        48: \"DNSKEY\",\n        49: \"DHCID\",\n        50: \"NSEC3\",\n        51: \"NSEC3PARAM\",\n        52: \"TLSA\",\n        53: \"HIP\",\n        55: \"HIP\",\n        59: \"CDS\",\n        60: \"CDNSKEY\",\n        61: \"OPENPGPKEY\",\n        62: \"CSYNC\",\n        63: \"ZONEMD\",\n        64: \"SVCB\",\n        65: \"HTTPS\",\n        99: \"SPF\",\n        108: \"EUI48\",\n        109: \"EUI64\",\n        249: \"TKEY\",\n        250: \"TSIG\",\n        251: \"IXFR\",\n        252: \"AXFR\",\n        255: \"ANY\",\n        256: \"URI\",\n        257: \"CAA\",\n        32768: \"TA\",\n        32769: \"DLV\",\n    },\n    unknown_qtype,\n)\n</code></pre> <p>QTYPE <code>Bimap</code> - allows bi-directional mapping between integer and text representations</p>"},{"location":"reference/dnslib/dns/#dnslib.dns.RCODE","title":"RCODE  <code>module-attribute</code>","text":"<pre><code>RCODE = Bimap(\n    \"RCODE\",\n    {\n        0: \"NOERROR\",\n        1: \"FORMERR\",\n        2: \"SERVFAIL\",\n        3: \"NXDOMAIN\",\n        4: \"NOTIMP\",\n        5: \"REFUSED\",\n        6: \"YXDOMAIN\",\n        7: \"YXRRSET\",\n        8: \"NXRRSET\",\n        9: \"NOTAUTH\",\n        10: \"NOTZONE\",\n    },\n    DNSError,\n)\n</code></pre> <p>RCODE <code>Bimap</code> - allows bi-directional mapping between integer and text representations</p>"},{"location":"reference/dnslib/dns/#dnslib.dns.A","title":"A","text":"<pre><code>A(data: Union[str, bytes, int, IPv4Address])\n</code></pre> <p>             Bases: <code>RD</code></p> <p>IPv4 Host Address</p> <p>References:</p> <ul> <li>https://datatracker.ietf.org/doc/html/rfc1035#section-3.4.1</li> </ul> <p>Changed in 1.0: <code>self.data</code> property is now an <code>IPv4Address</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[str, bytes, int, IPv4Address]</code> <p>IPv4 Address</p> required <p>Changed in 1.0: <code>data</code> must be one of <code>str</code>, <code>bytes</code>, <code>int</code>, <code>IPv4Address</code> (it can no longer be <code>tuple</code>, <code>list</code>).</p>"},{"location":"reference/dnslib/dns/#dnslib.dns.AAAA","title":"AAAA","text":"<pre><code>AAAA(data: Union[str, bytes, int, IPv6Address])\n</code></pre> <p>             Bases: <code>RD</code></p> <p>IPv6 Host Address</p> <p>References:</p> <ul> <li>https://datatracker.ietf.org/doc/html/rfc3596</li> </ul> <p>Changed in 1.0: <code>self.data</code> property is now an <code>IPv46ddress</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[str, bytes, int, IPv6Address]</code> <p>the IPv6 Address</p> required <p>Changed in 1.0: <code>data</code> must be one of <code>str</code>, <code>bytes</code>, <code>int</code>, <code>IPv6Address</code> (it can no longer be <code>tuple</code>, <code>list</code>).</p>"},{"location":"reference/dnslib/dns/#dnslib.dns.CAA","title":"CAA","text":"<pre><code>CAA(flags: int, tag: str, value: str)\n</code></pre> <p>             Bases: <code>RD</code></p> <p>Certification Authority Authorization record</p> <p>Attributes:</p> Name Type Description <code>flags</code> <code>tag</code> <code>value</code> <p>References:</p> <ul> <li>https://datatracker.ietf.org/doc/html/rfc6844</li> </ul> <pre><code>&gt;&gt;&gt; CAA(0, 'issue', 'letsencrypt.org')\n0 issue \"letsencrypt.org\"\n&gt;&gt;&gt; a = DNSRecord()\n&gt;&gt;&gt; a.add_answer(*RR.fromZone('example.com 60 IN CAA 0 issue \"letsencrypt.org\"'))\n&gt;&gt;&gt; print(a)\n;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: ...\n;; flags: rd; QUERY: 0, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0\n;; ANSWER SECTION:\nexample.com.            60      IN      CAA     0 issue \"letsencrypt.org\"\n</code></pre>"},{"location":"reference/dnslib/dns/#dnslib.dns.CNAME","title":"CNAME","text":"<pre><code>CNAME(label: DNSLabelCreateTypes = None)\n</code></pre> <p>             Bases: <code>LabelOnlyRd</code></p> <p>Canonical Name for an alias</p> <p>Attributes:</p> Name Type Description <code>label</code> <p>References:</p> <ul> <li>https://datatracker.ietf.org/doc/html/rfc1035#section-3.3.1</li> </ul> <p>Changed in 1.0: Removed <code>[get,set]_label</code></p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>DNSLabelCreateTypes</code> <code>None</code>"},{"location":"reference/dnslib/dns/#dnslib.dns.DNAME","title":"DNAME","text":"<pre><code>DNAME(label: DNSLabelCreateTypes = None)\n</code></pre> <p>             Bases: <code>LabelOnlyRd</code></p> <p>Domain NAME record</p> <p>Attributes:</p> Name Type Description <code>label</code> <p>References:</p> <ul> <li>https://datatracker.ietf.org/doc/html/rfc6672</li> </ul> <p>Changed in 1.0: Removed <code>[get,set]_label</code></p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>DNSLabelCreateTypes</code> <code>None</code>"},{"location":"reference/dnslib/dns/#dnslib.dns.DNSHeader","title":"DNSHeader","text":"<pre><code>DNSHeader(\n    id: Optional[int] = None,\n    bitmap: Optional[int] = None,\n    q: Optional[int] = 0,\n    a: Optional[int] = 0,\n    auth: Optional[int] = 0,\n    ar: Optional[int] = 0,\n    **kwargs: int\n)\n</code></pre> <p>DNS Message Header</p> <p>References:</p> <ul> <li>https://datatracker.ietf.org/doc/html/rfc1035#section-4.1.1</li> <li>https://datatracker.ietf.org/doc/html/rfc2535#section-6.1</li> </ul> <p>Attributes:</p> Name Type Description <code>id</code> <p>(<code>ID</code>) message id</p> <p>Queries should generate this field, responses should copy this from the corresponding query.</p> <code>bitmap</code> <p>bytes containing combined qr, opcode, aa, tc, rd, ra, z, ad, cd, and rcode fields</p> <p>warning: You should not work with the bitmap directly.     Instead use the corresponding property attributes.     e.g. (<code>header.rd = 1</code>)</p> <code>qr</code> <p>(<code>QR</code>) query or response</p> <code>opcode</code> <p>(<code>OPCODE</code>) kind of query</p> <code>aa</code> <p>(<code>AA</code>) if message is authorative answer</p> <code>tc</code> <p>(<code>TC</code>) if message is truncated</p> <code>rd</code> <p>(<code>RD</code>) recursion desired</p> <code>ra</code> <p>(<code>RA</code>) recursion available</p> <code>z</code> <p>(<code>Z</code>) (reserved)</p> <code>ad</code> <p>(<code>AD</code>) authentic data (RFC2535, RFC3655)</p> <code>cd</code> <p>(<code>CD</code>) checking disabled (RFC2535, RFC3655)</p> <code>rcode</code> <p>(<code>RCODE</code>) response code</p> <code>q</code> <p>(<code>QDCOUNT</code>) number of questions</p> <code>a</code> <p>(<code>ANCOUNT</code>) number of answer records</p> <code>auth</code> <p>(<code>NSCOUNT</code>) number of name server resource record in authority section</p> <code>ar</code> <p>(<code>ARCOUNT</code>) number of additional records</p> <p>Changed in 1.0: Removed <code>[get,set]_[qr,opcode,aa,tc,rd,ra,z,ad,cd,rcode]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>Optional[int]</code> <p>message id. If <code>None</code> will be randomly generated.</p> <code>None</code> <code>bitmap</code> <code>Optional[int]</code> <p>integer representing fields. See <code>self.bitmap</code> for more details.</p> <code>None</code> <code>q</code> <code>Optional[int]</code> <p>question count</p> <code>0</code> <code>a</code> <code>Optional[int]</code> <p>answer record cound</p> <code>0</code> <code>auth</code> <code>Optional[int]</code> <p>authority name server record count</p> <code>0</code> <code>ar</code> <code>Optional[int]</code> <p>additional record count</p> <code>0</code> <code>kwargs</code> <code>int</code> <p>fields to in bitmap. See <code>self.bitmap</code> for list of fields.</p> <code>{}</code>"},{"location":"reference/dnslib/dns/#dnslib.dns.DNSKEY","title":"DNSKEY","text":"<pre><code>DNSKEY(\n    flags: int, protocol: int, algorithm: int, key: bytes\n)\n</code></pre> <p>             Bases: <code>RD</code></p> <p>DNSSEC Key</p> <p><code>DNSKEY</code> records are a part of DNSSEC</p> <p>Attributes:</p> Name Type Description <code>flags</code> <code>int</code> <code>protocol</code> <code>int</code> <code>algorithm</code> <code>int</code> <code>key</code> <code>bytes</code> <p>References:</p> <ul> <li>https://datatracker.ietf.org/doc/html/rfc4034#section-2</li> </ul>"},{"location":"reference/dnslib/dns/#dnslib.dns.DNSQuestion","title":"DNSQuestion","text":"<pre><code>DNSQuestion(\n    qname: DNSLabelCreateTypes = None,\n    qtype: int = 1,\n    qclass: int = 1,\n)\n</code></pre> <p>DNS MEssage Question section</p> <p>Attributes:</p> Name Type Description <code>qname</code> <code>qtype</code> <code>qclass</code> <p>Changed in 1.0: Removed <code>[set,get]_qname</code>.</p> <p>Parameters:</p> Name Type Description Default <code>qname</code> <code>DNSLabelCreateTypes</code> <code>None</code> <code>qtype</code> <code>int</code> <code>1</code> <code>qclass</code> <code>int</code> <code>1</code>"},{"location":"reference/dnslib/dns/#dnslib.dns.DNSRecord","title":"DNSRecord","text":"<pre><code>DNSRecord(\n    header: Optional[DNSHeader] = None,\n    questions: Optional[List[DNSQuestion]] = None,\n    rr: Optional[List[RR]] = None,\n    q: Optional[DNSQuestion] = None,\n    a: Optional[RR] = None,\n    auth: Optional[List[RR]] = None,\n    ar: Optional[List[RR]] = None,\n)\n</code></pre> <p>A DNS Message - corresponds to DNS packet</p> <p>Comprises of <code>DNSHeader</code>, <code>DNSQuestion</code>, and <code>RR</code> sections (answer,authority,additional)</p> <p>References:</p> <ul> <li>https://datatracker.ietf.org/doc/html/rfc1035#section-4</li> </ul> <p>Attributes:</p> Name Type Description <code>header</code> <code>DNSHeader</code> <p>header</p> <code>questions</code> <code>List[DNSQuestion]</code> <p>questions</p> <code>rr</code> <code>List[RR]</code> <p>answer records</p> <code>auth</code> <code>List[RR]</code> <p>authority records</p> <code>ar</code> <code>List[RR]</code> <p>additional records</p> <pre><code>&gt;&gt;&gt; d = DNSRecord()\n&gt;&gt;&gt; d.add_question(DNSQuestion(\"abc.com\")) # Or DNSRecord.question(\"abc.com\")\n&gt;&gt;&gt; d.add_answer(RR(\"abc.com\",QTYPE.CNAME,ttl=60,rdata=CNAME(\"ns.abc.com\")))\n&gt;&gt;&gt; d.add_auth(RR(\"abc.com\",QTYPE.SOA,ttl=60,rdata=SOA(\"ns.abc.com\",\"admin.abc.com\",(20140101,3600,3600,3600,3600))))\n&gt;&gt;&gt; d.add_ar(RR(\"ns.abc.com\",ttl=60,rdata=A(\"1.2.3.4\")))\n&gt;&gt;&gt; print(d)\n;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: ...\n;; flags: rd; QUERY: 1, ANSWER: 1, AUTHORITY: 1, ADDITIONAL: 1\n;; QUESTION SECTION:\n;abc.com.                       IN      A\n;; ANSWER SECTION:\nabc.com.                60      IN      CNAME   ns.abc.com.\n;; AUTHORITY SECTION:\nabc.com.                60      IN      SOA     ns.abc.com. admin.abc.com. 20140101 3600 3600 3600 3600\n;; ADDITIONAL SECTION:\nns.abc.com.             60      IN      A       1.2.3.4\n&gt;&gt;&gt; str(d) == str(DNSRecord.parse(d.pack()))\nTrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>header</code> <code>Optional[DNSHeader]</code> <p>header</p> <code>None</code> <code>questions</code> <code>Optional[List[DNSQuestion]]</code> <p>questions</p> <code>None</code> <code>rr</code> <code>Optional[List[RR]]</code> <p>resource records</p> <code>None</code> <code>q</code> <code>Optional[DNSQuestion]</code> <p>shortcut for single question</p> <code>None</code> <code>a</code> <code>Optional[RR]</code> <p>shortcut for single answer</p> <code>None</code> <code>auth</code> <code>Optional[List[RR]]</code> <p>authority records</p> <code>None</code> <code>ar</code> <code>Optional[List[RR]]</code> <p>additional records</p> <code>None</code>"},{"location":"reference/dnslib/dns/#dnslib.dns.DNSRecord.a","title":"a  <code>property</code>","text":"<pre><code>a: Optional[RR]\n</code></pre> <p>Get the first answer from this record if exists</p>"},{"location":"reference/dnslib/dns/#dnslib.dns.DNSRecord.q","title":"q  <code>property</code>","text":"<pre><code>q: Optional[DNSQuestion]\n</code></pre> <p>Get first question from this record if it exists</p>"},{"location":"reference/dnslib/dns/#dnslib.dns.DNSRecord.add_answer","title":"add_answer","text":"<pre><code>add_answer(*rr: RR) -&gt; None\n</code></pre> <p>Add answer(s)</p> <p>Parameters:</p> Name Type Description Default <code>rr</code> <code>RR</code> <p>records to add to answer section</p> <code>()</code> <pre><code>&gt;&gt;&gt; q = DNSRecord.question(\"abc.com\")\n&gt;&gt;&gt; a = q.reply()\n&gt;&gt;&gt; a.add_answer(*RR.fromZone(\"abc.com A 1.2.3.4\"))\n&gt;&gt;&gt; print(a)\n;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: ...\n;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0\n;; QUESTION SECTION:\n;abc.com.                       IN      A\n;; ANSWER SECTION:\nabc.com.                0       IN      A       1.2.3.4\n</code></pre>"},{"location":"reference/dnslib/dns/#dnslib.dns.DNSRecord.add_ar","title":"add_ar","text":"<pre><code>add_ar(*ar: RR) -&gt; None\n</code></pre> <p>Add additional records</p> <p>Parameters:</p> Name Type Description Default <code>ar</code> <code>RR</code> <p>records to add to additional section</p> <code>()</code> <pre><code>&gt;&gt;&gt; q = DNSRecord.question(\"abc.com\")\n&gt;&gt;&gt; a = q.reply()\n&gt;&gt;&gt; a.add_answer(*RR.fromZone(\"abc.com 60 CNAME x.abc.com\"))\n&gt;&gt;&gt; a.add_ar(*RR.fromZone(\"x.abc.com 3600 A 1.2.3.4\"))\n&gt;&gt;&gt; print(a)\n;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: ...\n;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1\n;; QUESTION SECTION:\n;abc.com.                       IN      A\n;; ANSWER SECTION:\nabc.com.                60      IN      CNAME   x.abc.com.\n;; ADDITIONAL SECTION:\nx.abc.com.              3600    IN      A       1.2.3.4\n</code></pre>"},{"location":"reference/dnslib/dns/#dnslib.dns.DNSRecord.add_auth","title":"add_auth","text":"<pre><code>add_auth(*auth: RR) -&gt; None\n</code></pre> <p>Add authority records</p> <p>Parameters:</p> Name Type Description Default <code>rr</code> <p>records to add to authority section</p> required <pre><code>&gt;&gt;&gt; q = DNSRecord.question(\"abc.com\")\n&gt;&gt;&gt; a = q.reply()\n&gt;&gt;&gt; a.add_answer(*RR.fromZone(\"abc.com 60 A 1.2.3.4\"))\n&gt;&gt;&gt; a.add_auth(*RR.fromZone(\"abc.com 3600 NS nsa.abc.com\"))\n&gt;&gt;&gt; print(a)\n;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: ...\n;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 1, ADDITIONAL: 0\n;; QUESTION SECTION:\n;abc.com.                       IN      A\n;; ANSWER SECTION:\nabc.com.                60      IN      A       1.2.3.4\n;; AUTHORITY SECTION:\nabc.com.                3600    IN      NS      nsa.abc.com.\n</code></pre>"},{"location":"reference/dnslib/dns/#dnslib.dns.DNSRecord.add_question","title":"add_question","text":"<pre><code>add_question(*q: DNSQuestion) -&gt; None\n</code></pre> <p>Add question(s) to this record</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>DNSQuestion</code> <p>question(s) to add</p> <code>()</code> <pre><code>&gt;&gt;&gt; q = DNSRecord()\n&gt;&gt;&gt; q.add_question(DNSQuestion(\"abc.com\"),\n...                DNSQuestion(\"abc.com\",QTYPE.MX))\n&gt;&gt;&gt; print(q)\n;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: ...\n;; flags: rd; QUERY: 2, ANSWER: 0, AUTHORITY: 0, ADDITIONAL: 0\n;; QUESTION SECTION:\n;abc.com.                       IN      A\n;abc.com.                       IN      MX\n</code></pre>"},{"location":"reference/dnslib/dns/#dnslib.dns.DNSRecord.diff","title":"diff","text":"<pre><code>diff(other: DNSRecord) -&gt; List[Tuple[Any, Any]]\n</code></pre> <p>Diff records - recursively diff sections (sorting RRs)</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>DNSRecord</code> <p>record to diff against</p> required <p>Returns:</p> Type Description <code>List[Tuple[Any, Any]]</code> <p>differences between the two records</p>"},{"location":"reference/dnslib/dns/#dnslib.dns.DNSRecord.format","title":"format","text":"<pre><code>format(prefix: str = '', sort: bool = False) -&gt; str\n</code></pre> <p>Formatted 'repr'-style representation of record</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>add this prefix to each section</p> <code>''</code> <code>sort</code> <code>bool</code> <p>if <code>True</code> sort each section first</p> <code>False</code>"},{"location":"reference/dnslib/dns/#dnslib.dns.DNSRecord.pack","title":"pack","text":"<pre><code>pack() -&gt; bytes\n</code></pre> <p>Pack record into binary packet</p> <pre><code>&gt;&gt;&gt; q = DNSRecord.question(\"abc.com\")\n&gt;&gt;&gt; q.header.id = 1234\n&gt;&gt;&gt; a = q.replyZone(\"abc.com A 1.2.3.4\")\n&gt;&gt;&gt; a.header.aa = 0\n&gt;&gt;&gt; pkt = a.pack()\n&gt;&gt;&gt; print(DNSRecord.parse(pkt))\n;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 1234\n;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0\n;; QUESTION SECTION:\n;abc.com.                       IN      A\n;; ANSWER SECTION:\nabc.com.                0       IN      A       1.2.3.4\n</code></pre>"},{"location":"reference/dnslib/dns/#dnslib.dns.DNSRecord.parse","title":"parse  <code>classmethod</code>","text":"<pre><code>parse(packet: bytes) -&gt; Self\n</code></pre> <p>Parse a DNS packet data into <code>DNSRecord</code> instance</p> <p>Recursively parses sections (calling appropriate parse method)</p> <p>Parameters:</p> Name Type Description Default <code>packet</code> <code>bytes</code> <p>DNS packet to parse</p> required <p>Raises:</p> Type Description <code>DNSError</code> <p>invalid DNS packet</p>"},{"location":"reference/dnslib/dns/#dnslib.dns.DNSRecord.question","title":"question  <code>staticmethod</code>","text":"<pre><code>question(\n    qname: str, qtype: str = \"A\", qclass: str = \"IN\"\n) -&gt; DNSRecord\n</code></pre> <p>Shortcut to create question</p> <p>Parameters:</p> Name Type Description Default <code>qname</code> <code>str</code> <p>name to query</p> required <code>qtype</code> <code>str</code> <p>type to query</p> <code>'A'</code> <code>qclass</code> <code>str</code> <p>class of query</p> <code>'IN'</code> <pre><code>&gt;&gt;&gt; q = DNSRecord.question(\"www.google.com\")\n&gt;&gt;&gt; print(q)\n;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: ...\n;; flags: rd; QUERY: 1, ANSWER: 0, AUTHORITY: 0, ADDITIONAL: 0\n;; QUESTION SECTION:\n;www.google.com.                IN      A\n\n&gt;&gt;&gt; q = DNSRecord.question(\"www.google.com\",\"NS\")\n&gt;&gt;&gt; print(q)\n;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: ...\n;; flags: rd; QUERY: 1, ANSWER: 0, AUTHORITY: 0, ADDITIONAL: 0\n;; QUESTION SECTION:\n;www.google.com.                IN      NS\n</code></pre>"},{"location":"reference/dnslib/dns/#dnslib.dns.DNSRecord.reply","title":"reply","text":"<pre><code>reply(ra: int = 1, aa: int = 1) -&gt; DNSRecord\n</code></pre> <p>Create skeleton reply packet</p> <p>Parameters:</p> Name Type Description Default <code>ra</code> <code>int</code> <p><code>DNSHeader.ra</code></p> <code>1</code> <code>aa</code> <code>int</code> <p><code>DNSHeader.aa</code></p> <code>1</code> <pre><code>&gt;&gt;&gt; q = DNSRecord.question(\"abc.com\")\n&gt;&gt;&gt; a = q.reply()\n&gt;&gt;&gt; a.add_answer(RR(\"abc.com\",QTYPE.A,rdata=A(\"1.2.3.4\"),ttl=60))\n&gt;&gt;&gt; print(a)\n;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: ...\n;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0\n;; QUESTION SECTION:\n;abc.com.                       IN      A\n;; ANSWER SECTION:\nabc.com.                60      IN      A       1.2.3.4\n</code></pre>"},{"location":"reference/dnslib/dns/#dnslib.dns.DNSRecord.replyZone","title":"replyZone","text":"<pre><code>replyZone(zone: str, ra: int = 1, aa: int = 1) -&gt; DNSRecord\n</code></pre> <p>Create a reply with response data in zone-file format</p> <p>Parameters:</p> Name Type Description Default <code>zone</code> <code>str</code> <p>zone to parse into answer</p> required <code>ra</code> <code>int</code> <p><code>DNSHeader.ra</code></p> <code>1</code> <code>aa</code> <code>int</code> <p><code>DNSHeader.aa</code></p> <code>1</code> <pre><code>&gt;&gt;&gt; q = DNSRecord.question(\"abc.com\")\n&gt;&gt;&gt; a = q.replyZone(\"abc.com 60 A 1.2.3.4\")\n&gt;&gt;&gt; print(a)\n;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: ...\n;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0\n;; QUESTION SECTION:\n;abc.com.                       IN      A\n;; ANSWER SECTION:\nabc.com.                60      IN      A       1.2.3.4\n</code></pre>"},{"location":"reference/dnslib/dns/#dnslib.dns.DNSRecord.send","title":"send","text":"<pre><code>send(\n    dest: str,\n    port: int = 53,\n    tcp: bool = False,\n    timeout: Optional[int] = None,\n    ipv6: bool = False,\n)\n</code></pre> <p>Send packet to a nameserver and return the response</p> <p>Parameters:</p> Name Type Description Default <code>dest</code> <code>str</code> <p>hostname of nameserver</p> required <code>port</code> <code>int</code> <p>port to connect to on nameserver</p> <code>53</code> <code>tcp</code> <code>bool</code> <p>If <code>True</code> uses TCP, otherwise UDP</p> <code>False</code> <code>timeout</code> <code>Optional[int]</code> <p>socket timeout</p> <code>None</code> <code>ipv6</code> <code>bool</code> <p>if <code>True</code> uses IPv6, otherwise IPv4</p> <code>False</code>"},{"location":"reference/dnslib/dns/#dnslib.dns.DNSRecord.set_header_qa","title":"set_header_qa","text":"<pre><code>set_header_qa() -&gt; None\n</code></pre> <p>Reset header q/a/auth/ar counts to match number of records</p> <p>This is normally done transparently, however if you've manually modified the the question, answer, authority, or additional lists in this record then you might need to call this function.</p>"},{"location":"reference/dnslib/dns/#dnslib.dns.DNSRecord.short","title":"short","text":"<pre><code>short() -&gt; str\n</code></pre> <p>Return RDATA with Zone formatting</p>"},{"location":"reference/dnslib/dns/#dnslib.dns.DNSRecord.toZone","title":"toZone","text":"<pre><code>toZone(prefix: str = '') -&gt; str\n</code></pre> <p>Formatted 'DiG' (zone) style output</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>add this prefix to each line</p> <code>''</code>"},{"location":"reference/dnslib/dns/#dnslib.dns.DNSRecord.truncate","title":"truncate","text":"<pre><code>truncate() -&gt; DNSRecord\n</code></pre> <p>Return truncated copy of DNSRecord (with TC flag set)</p> <p>The truncated copy will have all questions &amp; RRs removed</p> <pre><code>&gt;&gt;&gt; q = DNSRecord.question(\"abc.com\")\n&gt;&gt;&gt; a = q.reply()\n&gt;&gt;&gt; a.add_answer(*RR.fromZone(f\"abc.com IN TXT {'x' *255}\"))\n&gt;&gt;&gt; a.add_answer(*RR.fromZone(f\"abc.com IN TXT {'x' *255}\"))\n&gt;&gt;&gt; a.add_answer(*RR.fromZone(f\"abc.com IN TXT {'x' *255}\"))\n&gt;&gt;&gt; len(a.pack())\n829\n&gt;&gt;&gt; t = a.truncate()\n&gt;&gt;&gt; print(t)\n;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: ...\n;; flags: qr aa tc rd ra; QUERY: 0, ANSWER: 0, AUTHORITY: 0, ADDITIONAL: 0\n</code></pre>"},{"location":"reference/dnslib/dns/#dnslib.dns.DS","title":"DS","text":"<pre><code>DS(\n    key_tag: int,\n    algorithm: int,\n    digest_type: int,\n    digest: bytes,\n)\n</code></pre> <p>             Bases: <code>RD</code></p> <p>Delegation Signer record</p> <p><code>DS</code> records are a part of DNSSEC</p> <p>Attributes:</p> Name Type Description <code>key_tag</code> <code>algorithm</code> <code>digest_type</code> <code>digest</code> <p>References:</p> <ul> <li>https://datatracker.ietf.org/doc/html/rfc4034#section-5</li> </ul> <p>Parameters:</p> Name Type Description Default <code>key_tag</code> <code>int</code> required <code>algorithm</code> <code>int</code> required <code>digest_type</code> <code>int</code> required <code>digest</code> <code>bytes</code> required"},{"location":"reference/dnslib/dns/#dnslib.dns.EDNS0","title":"EDNS0","text":"<pre><code>EDNS0(\n    rname: DNSLabelCreateTypes = None,\n    rtype: int = QTYPE.OPT,\n    ext_rcode: int = 0,\n    version: int = 0,\n    flags: str = \"\",\n    udp_len: int = 0,\n    opts: Optional[List[EDNSOption]] = None,\n)\n</code></pre> <p>             Bases: <code>RR</code></p> <p>ENDS0 pseudo-record</p> <p>Wrapper around the ENDS0 support in RR to make it more convenient to create EDNS0 pseudo-record - this just makes it easier to specify the EDNS0 parameters directly</p> <p>EDNS flags should be passed as a space separated string of options (currently only 'do' is supported)</p> <pre><code>&gt;&gt;&gt; EDNS0(\"abc.com\",flags=\"do\",udp_len=2048,version=1)\n&lt;DNS OPT: edns_ver=1 do=1 ext_rcode=0 udp_len=2048&gt;\n&gt;&gt;&gt; print(_)\n;; OPT PSEUDOSECTION\n; EDNS: version: 1, flags: do; udp: 2048\n&gt;&gt;&gt; opt = EDNS0(\"abc.com\",flags=\"do\",ext_rcode=1,udp_len=2048,version=1,opts=[EDNSOption(1,b'abcd')])\n&gt;&gt;&gt; opt\n&lt;DNS OPT: edns_ver=1 do=1 ext_rcode=1 udp_len=2048&gt;\n&lt;EDNS Option: Code=1 Data='61626364'&gt;\n&gt;&gt;&gt; print(opt)\n;; OPT PSEUDOSECTION\n; EDNS: version: 1, flags: do; udp: 2048\n; EDNS: code: 1; data: 61626364\n&gt;&gt;&gt; r = DNSRecord.question(\"abc.com\").replyZone(\"abc.com A 1.2.3.4\")\n&gt;&gt;&gt; r.add_ar(opt)\n&gt;&gt;&gt; print(r)\n;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: ...\n;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1\n;; QUESTION SECTION:\n;abc.com.                       IN      A\n;; ANSWER SECTION:\nabc.com.                0       IN      A       1.2.3.4\n;; ADDITIONAL SECTION:\n;; OPT PSEUDOSECTION\n; EDNS: version: 1, flags: do; udp: 2048\n; EDNS: code: 1; data: 61626364\n&gt;&gt;&gt; DNSRecord.parse(r.pack()) == r\nTrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>rname</code> <code>DNSLabelCreateTypes</code> <code>None</code> <code>rtype</code> <code>int</code> <code>OPT</code> <code>ext_code</code> required <code>version</code> <code>int</code> <code>0</code> <code>flags</code> <code>str</code> <code>''</code> <code>udp_len</code> <code>int</code> <code>0</code> <code>opts</code> <code>Optional[List[EDNSOption]]</code> <code>None</code>"},{"location":"reference/dnslib/dns/#dnslib.dns.EDNS0.fromZone","title":"fromZone  <code>classmethod</code>","text":"<pre><code>fromZone(\n    zone: str,\n    origin: DNSLabelCreateTypes = None,\n    ttl: int = 0,\n) -&gt; List[Self]\n</code></pre> <p>Parse RR data from zone file and return list of RRs</p>"},{"location":"reference/dnslib/dns/#dnslib.dns.EDNSOption","title":"EDNSOption","text":"<pre><code>EDNSOption(code: int, data: bytes)\n</code></pre> <p>EDNSOption pseudo-section</p> <p>Very rudimentary support for EDNS0 options however this has not been tested due to a lack of data (anyone wanting to improve support or provide test data please raise an issue)</p> <p>Attributes:</p> Name Type Description <code>code</code> <code>data</code> <pre><code>&gt;&gt;&gt; EDNSOption(1,b\"1234\")\n&lt;EDNS Option: Code=1 Data='31323334'&gt;\n&gt;&gt;&gt; EDNSOption(99999,b\"1234\")\nTraceback (most recent call last):\n...\nValueError: Attribute 'code' must be between 0-65535 [99999]\n&gt;&gt;&gt; EDNSOption(1,None)\nTraceback (most recent call last):\n...\nValueError: Attribute 'data' must be instance of ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>int</code> required <code>data</code> <code>bytes</code> required"},{"location":"reference/dnslib/dns/#dnslib.dns.HTTPS","title":"HTTPS","text":"<pre><code>HTTPS(\n    priority: int,\n    target: DNSLabelCreateTypes,\n    params: List[Tuple[int, bytearray]],\n)\n</code></pre> <p>             Bases: <code>RD</code></p> <p>HTTPS record</p> <p>This is a type of <code>SVCB</code> record.</p> <p>Attributes:</p> Name Type Description <code>priority</code> <code>target</code> <code>params</code> <p>References:</p> <ul> <li>https://datatracker.ietf.org/doc/html/rfc9460</li> </ul> <pre><code>&gt;&gt;&gt; HTTPS.fromZone([\"1\", \"cloudflare.com.\"])\n1 cloudflare.com.\n&gt;&gt;&gt; HTTPS.fromZone([\"1\", \".\", \"mandatory=key65444,echconfig\"])\n1 . mandatory=key65444,echconfig\n&gt;&gt;&gt; HTTPS.fromZone([\"1\", \".\", \"alpn=h3,h3-29,h2\"])\n1 . alpn=h3,h3-29,h2\n&gt;&gt;&gt; HTTPS.fromZone([\"1\", \".\", \"no-default-alpn\"])\n1 . no-default-alpn\n&gt;&gt;&gt; HTTPS.fromZone([\"1\", \".\", \"port=443\"])\n1 . port=443\n&gt;&gt;&gt; HTTPS.fromZone([\"1\", \".\", \"ipv4hint=104.16.132.229,104.16.133.229\"])\n1 . ipv4hint=104.16.132.229,104.16.133.229\n&gt;&gt;&gt; HTTPS.fromZone([\"1\", \".\", \"echconfig=Z2FyYmFnZQ==\"])\n1 . echconfig=Z2FyYmFnZQ==\n&gt;&gt;&gt; HTTPS.fromZone([\"1\", \".\", \"ipv6hint=2606:4700::6810:84e5,2606:4700::6810:85e5\"])\n1 . ipv6hint=2606:4700::6810:84e5,2606:4700::6810:85e5\n&gt;&gt;&gt; HTTPS.fromZone([\"1\", \".\", \"key9999=X\"])\n1 . key9999=X\n&gt;&gt;&gt; pcap = bytes.fromhex(\n...     \"0001000001000c0268330568332d323902683200040008681084e5681085e5000600202606470000\"\n...     \"00000000000000681084e5260647000000000000000000681085e5\"\n... )\n&gt;&gt;&gt; obj = HTTPS.parse(DNSBuffer(pcap), len(pcap))\n&gt;&gt;&gt; obj\n1 . alpn=h3,h3-29,h2 ipv4hint=104.16.132.229,104.16.133.229 ipv6hint=2606:4700::6810:84e5,2606:4700::6810:85e5\n&gt;&gt;&gt; b = DNSBuffer()\n&gt;&gt;&gt; obj.pack(b)\n&gt;&gt;&gt; b.data == pcap\nTrue\n&gt;&gt;&gt; pcap = bytes.fromhex(\"00010000040004c0a80126\")\n&gt;&gt;&gt; obj = HTTPS.parse(DNSBuffer(pcap), len(pcap))\n&gt;&gt;&gt; obj\n1 . ipv4hint=192.168.1.38\n&gt;&gt;&gt; b = DNSBuffer()\n&gt;&gt;&gt; obj.pack(b)\n&gt;&gt;&gt; b.data == pcap\nTrue\n\n# Issue 43: HTTPS reads after RD end\n&gt;&gt;&gt; msg = bytes.fromhex(\n...     \"93088410000100020000000107646973636f726403636f6d0000410001c00c004100010000012c00\"\n...     \"2b0001000001000c0268330568332d323902683200040014a29f80e9a29f87e8a29f88e8a29f89e8\"\n...     \"a29f8ae8c00c002e00010000012c005f00410d020000012c632834e5632575c586c907646973636f\"\n...     \"726403636f6d0044d488ce4a5b9085289c671f0296b2b06cffaca28880c57643befd43d6de433d84\"\n...     \"ae078b282fc2cdd744f3bea2f201042a7a0d6f3e17ebd887b082bbe30dfda100002904d000008000\"\n...     \"0000\"\n... )\n&gt;&gt;&gt; print(DNSRecord.parse(msg))\n;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 37640\n;; flags: qr aa cd; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 1\n;; QUESTION SECTION:\n;discord.com.                   IN      HTTPS\n;; ANSWER SECTION:\ndiscord.com.            300     IN      HTTPS   1 . alpn=h3,h3-29,h2 ipv4hint=162.159.128.233,162.159.135.232,162.159.136.232,162.159.137.232,162.159.138.232\ndiscord.com.            300     IN      RRSIG   HTTPS 13 2 300 20220919092245 20220917072245 34505 discord.com. RNSIzkpbkIUonGcfApaysGz/rKKIgMV2Q779Q9beQz2ErgeLKC/CzddE876i8gEEKnoNbz4X69iHsIK74w39oQ==\n;; ADDITIONAL SECTION:\n;; OPT PSEUDOSECTION\n; EDNS: version: 0, flags: do; udp: 1232\n</code></pre> <p>Changed in 1.0: <code>target</code> is now a <code>DNSLabel</code> property.</p> <p>Parameters:</p> Name Type Description Default <code>priority</code> <code>int</code> required <code>target</code> <code>DNSLabelCreateTypes</code> required <code>params</code> <code>List[Tuple[int, bytearray]]</code> required"},{"location":"reference/dnslib/dns/#dnslib.dns.LOC","title":"LOC","text":"<pre><code>LOC(\n    lat: int,\n    lon: int,\n    alt: int,\n    siz: float = 1.0,\n    hp: float = 10000.0,\n    vp: float = 10.0,\n)\n</code></pre> <p>             Bases: <code>RD</code></p> <p>Location record</p> <p>Attributes:</p> Name Type Description <code>lat</code> <p>lattitude</p> <code>lon</code> <p>longitude</p> <code>alt</code> <p>altitude</p> <code>siz</code> <p>the diameter of a sphere enclosing the described entity</p> <code>hp</code> <p>horizontal precision - This is the diameter of the horizontal \"circle of error\", rather than a \"plus or minus\" value</p> <code>vp</code> <p>verticial precision - This is the total potential vertical error, rather than a \"plus or minus\" value.</p> <p>References:</p> <ul> <li>https://datatracker.ietf.org/doc/html/rfc1876</li> </ul> <pre><code>&gt;&gt;&gt; LOC(37.236693, -115.804069, 1381.0)\n37 14 12.094 N 115 48 14.649 W 1381.00m\n&gt;&gt;&gt; LOC(37.236693, -115.804069, 1381.0, 3000.0, 1.0, 1.0)\n37 14 12.094 N 115 48 14.649 W 1381.00m 3000.00m 1.00m 1.00m\n&gt;&gt;&gt; a = DNSRecord(DNSHeader(id=1456))\n&gt;&gt;&gt; a.add_answer(*RR.fromZone('area51.local. 60 IN LOC 37 14 12.094 N 115 48 14.649 W 1381.00m'))\n&gt;&gt;&gt; a.add_answer(*RR.fromZone('area51.local. 60 IN LOC 37 N 115 48 W 1381.00m'))\n&gt;&gt;&gt; a.add_answer(*RR.fromZone('area51.local. 60 IN LOC 37 14 12.094 N 115 48 14.649 W 1381.00m 1m 10000m 10m'))\n&gt;&gt;&gt; print(a)\n;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 1456\n;; flags: rd; QUERY: 0, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 0\n;; ANSWER SECTION:\narea51.local.           60      IN      LOC     37 14 12.094 N 115 48 14.649 W 1381.00m\narea51.local.           60      IN      LOC     37 N 115 48 W 1381.00m\narea51.local.           60      IN      LOC     37 14 12.094 N 115 48 14.649 W 1381.00m\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>lat</code> <code>int</code> required <code>lon</code> <code>int</code> required <code>alt</code> <code>int</code> required <code>siz</code> <code>float</code> <code>1.0</code> <code>hp</code> <code>float</code> <code>10000.0</code> <code>vp</code> <code>float</code> <code>10.0</code>"},{"location":"reference/dnslib/dns/#dnslib.dns.LabelOnlyRd","title":"LabelOnlyRd","text":"<pre><code>LabelOnlyRd(label: DNSLabelCreateTypes = None)\n</code></pre> <p>             Bases: <code>RD</code></p> <p>Base class for RD types that only have a label</p> <p>Attributes:</p> Name Type Description <code>label</code> <p>New in 1.0</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>DNSLabelCreateTypes</code> <code>None</code>"},{"location":"reference/dnslib/dns/#dnslib.dns.MX","title":"MX","text":"<pre><code>MX(label: DNSLabelCreateTypes = None, preference: int = 10)\n</code></pre> <p>             Bases: <code>RD</code></p> <p>Mail exchange record</p> <p>Attributes:</p> Name Type Description <code>label</code> <code>DNSLabel</code> <code>preference</code> <code>int</code> <p>References:</p> <ul> <li>https://datatracker.ietf.org/doc/html/rfc1035#autoid-27</li> </ul> <p>Changed in 1.0: Removed <code>[get,set]_label</code></p>"},{"location":"reference/dnslib/dns/#dnslib.dns.NAPTR","title":"NAPTR","text":"<pre><code>NAPTR(\n    order: int,\n    preference: int,\n    flags: bytes,\n    service: bytes,\n    regexp: bytes,\n    replacement: DNSLabelCreateTypes = None,\n)\n</code></pre> <p>             Bases: <code>RD</code></p> <p>Naming Authority Pointer</p> <p>NAPTR is part of the Dynamic Delegation Discovery System (DDDS).</p> <p>Attributes:</p> Name Type Description <code>order</code> <code>preference</code> <code>flags</code> <code>service</code> <code>regexp</code> <code>replacement</code> <p>References:</p> <ul> <li>https://datatracker.ietf.org/doc/html/rfc3403</li> </ul> <p>Changed in 1.0: Removed <code>[get,set]_replacement</code></p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>int</code> required <code>preference</code> <code>int</code> required <code>flags</code> <code>bytes</code> required <code>service</code> <code>bytes</code> required <code>regexp</code> <code>bytes</code> required <code>replacement</code> <code>DNSLabelCreateTypes</code> <code>None</code>"},{"location":"reference/dnslib/dns/#dnslib.dns.NS","title":"NS","text":"<pre><code>NS(label: DNSLabelCreateTypes = None)\n</code></pre> <p>             Bases: <code>LabelOnlyRd</code></p> <p>Authoritive Name Server</p> <p>Attributes:</p> Name Type Description <code>label</code> <p>References:</p> <ul> <li>https://datatracker.ietf.org/doc/html/rfc1035#section-3.3.11</li> </ul> <p>Changed in 1.0: Removed <code>[get,set]_label</code></p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>DNSLabelCreateTypes</code> <code>None</code>"},{"location":"reference/dnslib/dns/#dnslib.dns.NSEC","title":"NSEC","text":"<pre><code>NSEC(label: DNSLabelCreateTypes, rrlist: List[str])\n</code></pre> <p>             Bases: <code>RD</code></p> <p>NSEC record</p> <p><code>NSEC</code> records are a part of DNSSEC</p> <p>Attributes:</p> Name Type Description <code>label</code> <code>rrlist</code> <p>References:</p> <ul> <li>https://datatracker.ietf.org/doc/html/rfc4034#section-4</li> </ul> <p>Changed in 1.0: Removed <code>[get,set]_replacement</code></p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>DNSLabelCreateTypes</code> required <code>rrlist</code> <code>List[str]</code> required"},{"location":"reference/dnslib/dns/#dnslib.dns.OPT","title":"OPT","text":"<pre><code>OPT(options: Optional[List[EDNSOption]] = None)\n</code></pre> <p>             Bases: <code>RD</code></p> <p>Pseudo RDATA for EDNS Options</p> <p>References:</p> <ul> <li>https://datatracker.ietf.org/doc/html/rfc6891#section-6.1.2</li> </ul> <p>New in 1.0</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>Optional[List[EDNSOption]]</code> <p>list of <code>EDNSOption</code></p> <code>None</code>"},{"location":"reference/dnslib/dns/#dnslib.dns.PTR","title":"PTR","text":"<pre><code>PTR(label: DNSLabelCreateTypes = None)\n</code></pre> <p>             Bases: <code>LabelOnlyRd</code></p> <p>Domain Name Pointer</p> <p>Attributes:</p> Name Type Description <code>label</code> <p>References:</p> <ul> <li>https://datatracker.ietf.org/doc/html/rfc1035#section-3.3.12</li> </ul> <p>Changed in 1.0: Removed <code>[get,set]_label</code></p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>DNSLabelCreateTypes</code> <code>None</code>"},{"location":"reference/dnslib/dns/#dnslib.dns.RD","title":"RD","text":"<pre><code>RD(data: bytes = b'')\n</code></pre> <p>Base RD object - also used as placeholder for unknown RD types</p> <p>To create a new RD type subclass this and add to RDMAP (below)</p> <p>Subclass should implement (as a minimum):</p> <ul> <li><code>parse</code> (<code>classmethod</code>) - decode new instance from packet data</li> <li><code>fromZone</code> - decode new instance from Zone file</li> <li><code>__init__</code> - create class</li> <li><code>pack</code> - encode to packet data</li> <li><code>toZone</code> - encode to zone format</li> </ul> <p>Unknown rdata types default to RD and store rdata as a binary blob (this allows round-trip encoding/decoding)</p> <p>Changed in 1.0: <code>__repr__</code> now defaults to calling <code>toZone</code> (previously was the opposite). Thus child classes should implement <code>toZone</code> for Zone file formatting. This makes it explicit to the expected format and allows for non-default <code>repr</code> formats without impacting the Zone formatting.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>raw RDATA</p> <code>b''</code>"},{"location":"reference/dnslib/dns/#dnslib.dns.RD.fromZone","title":"fromZone  <code>classmethod</code>","text":"<pre><code>fromZone(rd: List[str], origin=None) -&gt; Self\n</code></pre> <p>Parse RDATA from parsed Zone file</p> <p>Child classes should override this method</p> <p>Parameters:</p> Name Type Description Default <code>rd</code> <code>List[str]</code> <p>Zonefile entry as list of strings</p> required <code>origin</code> <p>Zone File <code>$ORIGIN</code></p> <code>None</code>"},{"location":"reference/dnslib/dns/#dnslib.dns.RD.pack","title":"pack","text":"<pre><code>pack(buffer: DNSBuffer) -&gt; None\n</code></pre> <p>Pack record into buffer</p> <p>Child classes should override this method</p> <p>Parameters:</p> Name Type Description Default <code>buffer</code> <code>DNSBuffer</code> required"},{"location":"reference/dnslib/dns/#dnslib.dns.RD.parse","title":"parse  <code>classmethod</code>","text":"<pre><code>parse(buffer: DNSBuffer, length: int) -&gt; Self\n</code></pre> <p>Unpack from buffer</p> <p>Child classes should override this method</p> <p>Parameters:</p> Name Type Description Default <code>buffer</code> <code>DNSBuffer</code> <p>buffer to read from</p> required <code>length</code> <code>int</code> <p>length of rdata</p> required"},{"location":"reference/dnslib/dns/#dnslib.dns.RD.toZone","title":"toZone","text":"<pre><code>toZone() -&gt; str\n</code></pre> <p>Encode this RDATA into Zone file format.</p> <p>Child classes should override this method</p>"},{"location":"reference/dnslib/dns/#dnslib.dns.RP","title":"RP","text":"<pre><code>RP(\n    mbox: DNSLabelCreateTypes = None,\n    txt: DNSLabelCreateTypes = None,\n)\n</code></pre> <p>             Bases: <code>RD</code></p> <p>Responsible Person record</p> <p>Attributes:</p> Name Type Description <code>mbox</code> <p>a domain name that specifies the mailbox for the responsible person. This is in the same format as the <code>RNAME</code> field in a <code>SOA</code> record.</p> <code>txt</code> <p>domain name which can be queried for <code>TXT</code> records for additional information.</p> <p>References:</p> <ul> <li>https://datatracker.ietf.org/doc/html/rfc1183</li> </ul> <p>Changed in 1.0: Removed <code>[get,set]_[mbox,txt]</code></p> <p>Parameters:</p> Name Type Description Default <code>mbox</code> <code>DNSLabelCreateTypes</code> <code>None</code> <code>txt</code> <code>DNSLabelCreateTypes</code> <code>None</code>"},{"location":"reference/dnslib/dns/#dnslib.dns.RR","title":"RR","text":"<pre><code>RR(\n    rname: DNSLabelCreateTypes = None,\n    rtype: int = 1,\n    rclass: int = 1,\n    ttl: int = 0,\n    rdata: Optional[RD] = None,\n)\n</code></pre> <p>DNS Resource Record</p> <p>Contains RR header and RD (resource data) instance</p> <p>Attributes:</p> Name Type Description <code>rname</code> <code>DNSLabel</code> <p>(<code>NAME</code>) the name of the node to which this resource record pertains.</p> <code>rtype</code> <code>int</code> <p>(<code>TYPE</code>) two octets containing one of the RR TYPE codes.</p> <code>rclass</code> <code>int</code> <p>(<code>CLASS</code>) two octets containing one of the RR CLASS codes.</p> <code>ttl</code> <code>int</code> <p>(<code>TTL</code>) a 32 bit signed integer that specifies the time interval that the resource record may be cached before the source of the information should again be consulted.  Zero values are interpreted to mean that the RR can only be used for the transaction in progress, and should not be cached.  For example, SOA records are always distributed with a zero TTL to prohibit caching.  Zero values can also be used for extremely volatile data.</p> <code>rdlength</code> <code>int</code> <p>(<code>RDLENGTH</code>) an unsigned 16 bit integer that specifies the length in     octets of the RDATA field.</p> <code>edns_do</code> <code>int</code> <p>???</p> <p>References:</p> <ul> <li>https://datatracker.ietf.org/doc/html/rfc1035#section-3.2</li> </ul> <p>Changed in 1.0:</p> <pre><code>- remove `[get,set]_[rname,do]`\n- EDNS Pseudo records (`QTYPE.OPT`) now use `OPT` to hold options.\n- `self.rdata` is now never `None`. If `rdata` is `None` then an empty `RD()` is used.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>rname</code> <code>DNSLabelCreateTypes</code> <code>None</code> <code>rtype</code> <code>int</code> <code>1</code> <code>rclass</code> <code>int</code> <code>1</code> <code>ttl</code> <code>int</code> <code>0</code> <code>rdata</code> <code>Optional[RD]</code> <code>None</code>"},{"location":"reference/dnslib/dns/#dnslib.dns.RR.fromZone","title":"fromZone  <code>classmethod</code>","text":"<pre><code>fromZone(\n    zone: str,\n    origin: DNSLabelCreateTypes = None,\n    ttl: int = 0,\n) -&gt; List[Self]\n</code></pre> <p>Parse RR data from zone file and return list of RRs</p>"},{"location":"reference/dnslib/dns/#dnslib.dns.RRSIG","title":"RRSIG","text":"<pre><code>RRSIG(\n    covered: int,\n    algorithm: int,\n    labels: int,\n    orig_ttl: int,\n    sig_exp: int,\n    sig_inc: int,\n    key_tag: int,\n    name: DNSLabelCreateTypes,\n    sig: bytes,\n)\n</code></pre> <p>             Bases: <code>RD</code></p> <p>Resource Record Set Signature</p> <p><code>RRSIG</code> records are a part of DNSSEC</p> <p>Attributes:</p> Name Type Description <code>covered</code> <code>algorithm</code> <code>labels</code> <code>orig_ttl</code> <code>sig_exp</code> <code>sig_inc</code> <code>key_tag</code> <p>References:</p> <ul> <li>https://datatracker.ietf.org/doc/html/rfc4034#section-3</li> </ul> <p>Parameters:</p> Name Type Description Default <code>covered</code> <code>int</code> required <code>algorithm</code> <code>int</code> required <code>labels</code> <code>int</code> required <code>orig_ttl</code> <code>int</code> required <code>sig_exp</code> <code>int</code> required <code>sig_inc</code> <code>int</code> required <code>key_tag</code> <code>int</code> required <code>name</code> <code>DNSLabelCreateTypes</code> required <code>sig</code> <code>bytes</code> required"},{"location":"reference/dnslib/dns/#dnslib.dns.SOA","title":"SOA","text":"<pre><code>SOA(\n    mname: DNSLabelCreateTypes = None,\n    rname: DNSLabelCreateTypes = None,\n    times: Union[\n        List[int], Tuple[int, int, int, int, int], None\n    ] = None,\n)\n</code></pre> <p>             Bases: <code>RD</code></p> <p>Start Of Authority record</p> <p>Attributes:</p> Name Type Description <code>times</code> <code>label</code> <p>References:</p> <ul> <li>https://datatracker.ietf.org/doc/html/rfc1035#section-3.3.13</li> </ul> <p>Changed in 1.0: Removed <code>[get,set]_[mname,rname]</code></p>"},{"location":"reference/dnslib/dns/#dnslib.dns.SRV","title":"SRV","text":"<pre><code>SRV(\n    priority: int = 0,\n    weight: int = 0,\n    port: int = 0,\n    target: DNSLabelCreateTypes = None,\n)\n</code></pre> <p>             Bases: <code>RD</code></p> <p>Service Location record</p> <p>Attributes:</p> Name Type Description <code>priority</code> <code>weight</code> <code>port</code> <code>target</code> <p>References:</p> <ul> <li>https://datatracker.ietf.org/doc/html/rfc2782</li> </ul> <p>Changed in 1.0: Removed <code>[get,set]_target</code></p> <p>Parameters:</p> Name Type Description Default <code>priority</code> <code>int</code> <code>0</code> <code>weight</code> <code>int</code> <code>0</code> <code>port</code> <code>int</code> <code>0</code> <code>target</code> <code>DNSLabelCreateTypes</code> <code>None</code>"},{"location":"reference/dnslib/dns/#dnslib.dns.SSHFP","title":"SSHFP","text":"<pre><code>SSHFP(algorithm: int, fp_type: int, fingerprint: bytes)\n</code></pre> <p>             Bases: <code>RD</code></p> <p>SSH Fingerprint record</p> Atrributes <p>algorithm: fp_type: fingerprint:</p> <p>References:</p> <ul> <li>https://datatracker.ietf.org/doc/html/rfc4255</li> </ul> <p>Parameters:</p> Name Type Description Default <code>algorithm</code> <code>int</code> required <code>fp_type</code> <code>int</code> required <code>fingerprint</code> <code>bytes</code> required"},{"location":"reference/dnslib/dns/#dnslib.dns.TLSA","title":"TLSA","text":"<pre><code>TLSA(\n    cert_usage: int,\n    selector: int,\n    matching_type: int,\n    cert_data: bytes,\n)\n</code></pre> <p>             Bases: <code>RD</code></p> <p>TLSA record</p> <p>This is part of The DNS-Based Authentication of Named Entities (DANE) Transport Layer Security (TLS) Protocol</p> <p>Attributes:</p> Name Type Description <code>cert_usage</code> <code>selector</code> <code>matching_type</code> <code>cert_data</code> <p>References:</p> <ul> <li>https://datatracker.ietf.org/doc/html/rfc6698</li> </ul>"},{"location":"reference/dnslib/dns/#dnslib.dns.TXT","title":"TXT","text":"<pre><code>TXT(\n    texts: Union[Sequence[bytes], Sequence[str], bytes, str]\n)\n</code></pre> <p>             Bases: <code>RD</code></p> <p>Text Record</p> <p>Pass in either a single byte/unicode string, or a tuple/list of byte/unicode strings. (byte strings are preferred as this avoids possible encoding issues)</p> <p>References:</p> <ul> <li>https://datatracker.ietf.org/doc/html/rfc1035#section-3.3.14</li> </ul> <p>Note:</p> <p> is a single length octet followed by that number of characters.   is treated as binary information, and can be up to 256 characters in length (including the length octet). <pre><code>&gt;&gt;&gt; TXT(b'txtvers=1')\n\"txtvers=1\"\n&gt;&gt;&gt; TXT((b'txtvers=1',))\n\"txtvers=1\"\n&gt;&gt;&gt; TXT([b'txtvers=1',])\n\"txtvers=1\"\n&gt;&gt;&gt; TXT([b'txtvers=1',b'swver=2.5'])\n\"txtvers=1\",\"swver=2.5\"\n&gt;&gt;&gt; TXT(['txtvers=1','swver=2.5'])\n\"txtvers=1\",\"swver=2.5\"\n&gt;&gt;&gt; a = DNSRecord()\n&gt;&gt;&gt; a.add_answer(*RR.fromZone('example.com 60 IN TXT \"txtvers=1\"'))\n&gt;&gt;&gt; a.add_answer(*RR.fromZone('example.com 120 IN TXT \"txtvers=1\" \"swver=2.3\"'))\n&gt;&gt;&gt; print(a)\n;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: ...\n;; flags: rd; QUERY: 0, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 0\n;; ANSWER SECTION:\nexample.com.            60      IN      TXT     \"txtvers=1\"\nexample.com.            120     IN      TXT     \"txtvers=1\" \"swver=2.3\"\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>texts</code> <code>Union[Sequence[bytes], Sequence[str], bytes, str]</code> required"},{"location":"reference/dnslib/dns/#dnslib.dns.ZoneParser","title":"ZoneParser","text":"<pre><code>ZoneParser(\n    zone: str,\n    origin: DNSLabelCreateTypes = None,\n    ttl: int = 0,\n)\n</code></pre> <p>Zone file parser</p> <pre><code>&gt;&gt;&gt; z = ZoneParser(\"www.example.com. 60 IN A 1.2.3.4\")\n&gt;&gt;&gt; list(z.parse())\n[&lt;DNS RR: 'www.example.com.' rtype=A rclass=IN ttl=60 rdata='1.2.3.4'&gt;]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>zone</code> <code>str</code> <p>Zone file to parse</p> required <code>origin</code> <code>DNSLabelCreateTypes</code> <p>origin of zone file</p> <code>None</code> <code>ttl</code> <code>int</code> <p>default ttl</p> <code>0</code>"},{"location":"reference/dnslib/dns/#dnslib.dns.ZoneParser.parse","title":"parse","text":"<pre><code>parse() -&gt; Generator[RR, None, None]\n</code></pre> <p>Parse all records</p>"},{"location":"reference/dnslib/dns/#dnslib.dns.create_label","title":"create_label","text":"<pre><code>create_label(\n    label: str, origin: DNSLabelCreateTypes = None\n) -&gt; DNSLabel\n</code></pre> <p>Create a DNSLabel from a string</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> required <code>origin</code> <code>DNSLabelCreateTypes</code> <p>base of label if label is not connected to root (<code>.</code>).</p> <code>None</code> <p>Changed in 1.0: renamed from <code>label</code> to <code>create_label</code> (avoids name collisions within classes)</p>"},{"location":"reference/dnslib/dns/#dnslib.dns.create_label_property","title":"create_label_property","text":"<pre><code>create_label_property(attr: str = 'label')\n</code></pre> <p>Property creator for DNSLabel properties</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>name of attribute</p> <code>'label'</code>"},{"location":"reference/dnslib/dns/#dnslib.dns.make_parse_error","title":"make_parse_error","text":"<pre><code>make_parse_error(\n    name: Union[str, Type], buffer, error: Exception\n) -&gt; DNSError\n</code></pre> <p>Generate a standardised DNSError for errors when parsing/unpacking from a buffer</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Union[str, Type]</code> <p>name of the thing being parsed/unpacked (e.g. <code>DNSQuestion</code>, <code>MX</code>)</p> required <code>buffer</code> <p>the buffer being parsed/unpacked</p> required <code>error</code> <code>Exception</code> <p>the exception that was thrown</p> required <p>Returns:</p> Type Description <code>DNSError</code> <p>Prepared <code>DNSError</code></p>"},{"location":"reference/dnslib/dns/#dnslib.dns.parse_time","title":"parse_time","text":"<pre><code>parse_time(s) -&gt; int\n</code></pre> <p>Parse time spec with optional s/m/h/d/w suffix</p> <p>Parameters:</p> Name Type Description Default <code>s</code> required <p>Returns:</p> Type Description <code>int</code> <p>number of seconds</p>"},{"location":"reference/dnslib/label/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> label","text":""},{"location":"reference/dnslib/label/#dnslib.label","title":"dnslib.label","text":"<p>DNSLabel/DNSBuffer - DNS label handling &amp; encoding/decoding</p>"},{"location":"reference/dnslib/label/#dnslib.label.DNSLabelCreateTypes","title":"DNSLabelCreateTypes  <code>module-attribute</code>","text":"<pre><code>DNSLabelCreateTypes = Union[\n    List[bytes],\n    Tuple[bytes, ...],\n    str,\n    bytes,\n    DNSLabel,\n    None,\n]\n</code></pre> <p>Type alias for types that can be used with <code>DNSLabel.__init__</code></p>"},{"location":"reference/dnslib/label/#dnslib.label.DNSBuffer","title":"DNSBuffer","text":"<pre><code>DNSBuffer(data=b'')\n</code></pre> <p>             Bases: <code>Buffer</code></p> <p>Extends Buffer to provide DNS name encoding/decoding (with caching)</p> <p>Attributes:</p> Name Type Description <code>data</code> <p>buffer data</p> <code>names</code> <code>Dict[Tuple[bytes, ...], int]</code> <p>cached labels</p> <pre><code>&gt;&gt;&gt; b = DNSBuffer()\n&gt;&gt;&gt; b.encode_name(b'aaa.bbb.ccc.')\n&gt;&gt;&gt; len(b)\n13\n&gt;&gt;&gt; b.encode_name(b'aaa.bbb.ccc.')\n&gt;&gt;&gt; len(b)\n15\n&gt;&gt;&gt; b.encode_name(b'xxx.yyy.zzz')\n&gt;&gt;&gt; len(b)\n28\n&gt;&gt;&gt; b.encode_name(b'zzz.xxx.bbb.ccc.')\n&gt;&gt;&gt; len(b)\n38\n&gt;&gt;&gt; b.encode_name(b'aaa.xxx.bbb.ccc')\n&gt;&gt;&gt; len(b)\n44\n&gt;&gt;&gt; b.offset = 0\n&gt;&gt;&gt; print(b.decode_name())\naaa.bbb.ccc.\n&gt;&gt;&gt; print(b.decode_name())\naaa.bbb.ccc.\n&gt;&gt;&gt; print(b.decode_name())\nxxx.yyy.zzz.\n&gt;&gt;&gt; print(b.decode_name())\nzzz.xxx.bbb.ccc.\n&gt;&gt;&gt; print(b.decode_name())\naaa.xxx.bbb.ccc.\n\n&gt;&gt;&gt; b = DNSBuffer()\n&gt;&gt;&gt; b.encode_name([b'a.aa',b'b.bb',b'c.cc'])\n&gt;&gt;&gt; b.offset = 0\n&gt;&gt;&gt; len(b.decode_name().label)\n3\n\n&gt;&gt;&gt; b = DNSBuffer()\n&gt;&gt;&gt; b.encode_name_nocompress(b'aaa.bbb.ccc.')\n&gt;&gt;&gt; len(b)\n13\n&gt;&gt;&gt; b.encode_name_nocompress(b'aaa.bbb.ccc.')\n&gt;&gt;&gt; len(b)\n26\n&gt;&gt;&gt; b.offset = 0\n&gt;&gt;&gt; print(b.decode_name())\naaa.bbb.ccc.\n&gt;&gt;&gt; print(b.decode_name())\naaa.bbb.ccc.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>data</code> <p>initial data</p> <code>b''</code>"},{"location":"reference/dnslib/label/#dnslib.label.DNSBuffer.remaining","title":"remaining  <code>property</code>","text":"<pre><code>remaining: int\n</code></pre> <p>Number of bytes from the current offset until the end of the buffer</p>"},{"location":"reference/dnslib/label/#dnslib.label.DNSBuffer.append","title":"append","text":"<pre><code>append(s: bytes) -&gt; None\n</code></pre> <p>Append data to end of the buffer and increment offset</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>bytes</code> <p>data to append</p> required"},{"location":"reference/dnslib/label/#dnslib.label.DNSBuffer.append_with_length","title":"append_with_length","text":"<pre><code>append_with_length(length_format: str, s: bytes) -&gt; None\n</code></pre> <p>Append length prefixed data to the buffer.</p> <p>Is a shortcut to calling:</p> <pre><code>buffer.pack(\"H\", len(data))\nbuffer.append(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>length_format</code> <code>str</code> <p>struct format of the length</p> required <code>s</code> <code>bytes</code> <p>data to append</p> required <p>New in 1.0</p>"},{"location":"reference/dnslib/label/#dnslib.label.DNSBuffer.decode_name","title":"decode_name","text":"<pre><code>decode_name(_last: int = -1) -&gt; DNSLabel\n</code></pre> <p>Decode label at current offset in buffer</p> <p>Follows pointers to cached elements where necessary</p> <p>Parameters:</p> Name Type Description Default <code>_last</code> <code>int</code> <p>Pointer to previous name. Used internally to allow following</p> <code>-1</code>"},{"location":"reference/dnslib/label/#dnslib.label.DNSBuffer.encode_name","title":"encode_name","text":"<pre><code>encode_name(name: DNSLabelCreateTypes) -&gt; None\n</code></pre> <p>Encode label and store at end of the buffer using compression where possible</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>DNSLabelCreateTypes</code> <p>name to encode</p> required"},{"location":"reference/dnslib/label/#dnslib.label.DNSBuffer.encode_name_nocompress","title":"encode_name_nocompress","text":"<pre><code>encode_name_nocompress(name: DNSLabelCreateTypes) -&gt; None\n</code></pre> <p>Encode and store label with no compression</p> <p>This is needed for <code>RRSIG</code></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>DNSLabelCreateTypes</code> <p>name to encode</p> required"},{"location":"reference/dnslib/label/#dnslib.label.DNSBuffer.get","title":"get","text":"<pre><code>get(length: int) -&gt; bytes\n</code></pre> <p>Get bytes from the buffer starting at the current offset and increment offset</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>number of bytes to get</p> required <p>Raises:</p> Type Description <code>BufferError</code> <p>if length is greater than remaining bytes.</p>"},{"location":"reference/dnslib/label/#dnslib.label.DNSBuffer.get_with_length","title":"get_with_length","text":"<pre><code>get_with_length(fmt: str) -&gt; bytes\n</code></pre> <p>Get bytes from the buffer using a length prefix</p> <p>This is a shortcut to:</p> <pre><code>data = buffer.get(buffer.unpack_one(\"!H\"))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>fmt</code> <code>str</code> <p>struct format of length prefix, must return a single value.</p> required"},{"location":"reference/dnslib/label/#dnslib.label.DNSBuffer.hex","title":"hex","text":"<pre><code>hex() -&gt; str\n</code></pre> <p>Return data as hex string</p>"},{"location":"reference/dnslib/label/#dnslib.label.DNSBuffer.pack","title":"pack","text":"<pre><code>pack(fmt: str, *args) -&gt; None\n</code></pre> <p>Pack a struct and append it to the buffer</p> <p>Parameters:</p> Name Type Description Default <code>fmt</code> <code>str</code> <p>struct format</p> required <code>args</code> <p>data to pack into the struct</p> <code>()</code>"},{"location":"reference/dnslib/label/#dnslib.label.DNSBuffer.unpack","title":"unpack","text":"<pre><code>unpack(fmt: str) -&gt; Tuple\n</code></pre> <p>Unpack a struct from the current offset and increment offset</p> <p>Parameters:</p> Name Type Description Default <code>fmt</code> <code>str</code> <p>struct format to unpack</p> required <p>Raises:</p> Type Description <code>BufferError</code> <p>if could not unpack struct</p>"},{"location":"reference/dnslib/label/#dnslib.label.DNSBuffer.unpack_one","title":"unpack_one","text":"<pre><code>unpack_one(fmt: str) -&gt; Any\n</code></pre> <p>Unpack a single value from the current offset and increment offset</p> <p>This is this a shortcut to using <code>unpack</code> with a struct that returns a <code>tuple</code> of length where you then need to extract the single value.</p> <p>Parameters:</p> Name Type Description Default <code>fmt</code> <code>str</code> <p>struct format to unpack</p> required <p>New in 1.0</p>"},{"location":"reference/dnslib/label/#dnslib.label.DNSBuffer.update","title":"update","text":"<pre><code>update(ptr: int, fmt: str, *args: Any) -&gt; None\n</code></pre> <p>Modify data at offset <code>ptr</code></p> <p>Parameters:</p> Name Type Description Default <code>ptr</code> <code>int</code> <p>the offset the start the modification at</p> required <code>fmt</code> <code>str</code> <p>struct format</p> required <code>args</code> <code>Any</code> <p>data to pack into struct format</p> <code>()</code>"},{"location":"reference/dnslib/label/#dnslib.label.DNSLabel","title":"DNSLabel","text":"<pre><code>DNSLabel(label: DNSLabelCreateTypes)\n</code></pre> <p>Container for DNS label (aka domain)</p> <p>Supports IDNA encoding for unicode domain names</p> <pre><code>&gt;&gt;&gt; l1 = DNSLabel(\"aaa.bbb.ccc.\")\n&gt;&gt;&gt; l2 = DNSLabel([b\"aaa\",b\"bbb\",b\"ccc\"])\n&gt;&gt;&gt; l1 == l2\nTrue\n&gt;&gt;&gt; l3 = DNSLabel(\"AAA.BBB.CCC\")\n&gt;&gt;&gt; l1 == l3\nTrue\n&gt;&gt;&gt; l1 == 'AAA.BBB.CCC'\nTrue\n&gt;&gt;&gt; x = { l1 : 1 }\n&gt;&gt;&gt; x[l1]\n1\n&gt;&gt;&gt; l1\n&lt;DNSLabel: 'aaa.bbb.ccc.'&gt;\n&gt;&gt;&gt; str(l1)\n'aaa.bbb.ccc.'\n&gt;&gt;&gt; l3 = l1.add(\"xxx.yyy\")\n&gt;&gt;&gt; l3\n&lt;DNSLabel: 'xxx.yyy.aaa.bbb.ccc.'&gt;\n&gt;&gt;&gt; l3.matchSuffix(l1)\nTrue\n&gt;&gt;&gt; l3.matchSuffix(\"xxx.yyy.\")\nFalse\n&gt;&gt;&gt; l3.matchSuffix(\"Bbb.ccc.\")\nTrue\n&gt;&gt;&gt; l3.stripSuffix(\"bbb.ccc.\")\n&lt;DNSLabel: 'xxx.yyy.aaa.'&gt;\n&gt;&gt;&gt; l3.matchGlob(\"*.[abc]aa.BBB.ccc\")\nTrue\n&gt;&gt;&gt; l3.matchGlob(\"*.[abc]xx.bbb.ccc\")\nFalse\n&gt;&gt;&gt; u1 = DNSLabel(\"\u2295.com\")\n&gt;&gt;&gt; str(u1) == \"xn--keh.com.\"\nTrue\n&gt;&gt;&gt; u1.idna == \"\u2295.com.\"\nTrue\n&gt;&gt;&gt; u1.label == ( b\"xn--keh\", b\"com\" )\nTrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>DNSLabelCreateTypes</code> <p>Label can be specified as: - a list/tuple of byte strings - a byte string (split into components separated by b'.') - a unicode string which will be encoded according to RFC3490/IDNA</p> required"},{"location":"reference/dnslib/label/#dnslib.label.DNSLabel.idna","title":"idna  <code>property</code>","text":"<pre><code>idna: str\n</code></pre> <p>Label in unicode</p>"},{"location":"reference/dnslib/label/#dnslib.label.DNSLabel.add","title":"add","text":"<pre><code>add(name: DNSLabelCreateTypes) -&gt; DNSLabel\n</code></pre> <p>Prepend name to label</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>DNSLabelCreateTypes</code> <p>name to prepend</p> required <p>Returns:</p> Type Description <code>DNSLabel</code> <p>new <code>DNSLabel</code></p>"},{"location":"reference/dnslib/label/#dnslib.label.DNSLabel.matchGlob","title":"matchGlob","text":"<pre><code>matchGlob(pattern: DNSLabelCreateTypes) -&gt; bool\n</code></pre> <p>Check if this label matches the given pattern</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>DNSLabelCreateTypes</code> <p>glob pattern to match on</p> required"},{"location":"reference/dnslib/label/#dnslib.label.DNSLabel.matchSuffix","title":"matchSuffix","text":"<pre><code>matchSuffix(suffix: DNSLabelCreateTypes) -&gt; bool\n</code></pre> <p>Return True if label suffix matches</p> <p>Parameters:</p> Name Type Description Default <code>suffix</code> <code>DNSLabelCreateTypes</code> <p>suffix to match</p> required"},{"location":"reference/dnslib/label/#dnslib.label.DNSLabel.stripSuffix","title":"stripSuffix","text":"<pre><code>stripSuffix(suffix: DNSLabelCreateTypes) -&gt; DNSLabel\n</code></pre> <p>Strip suffix from label</p> <p>Parameters:</p> Name Type Description Default <code>suffix</code> <code>DNSLabelCreateTypes</code> <p>suffix to strip</p> required"},{"location":"reference/dnslib/label/#dnslib.label.DNSLabelError","title":"DNSLabelError","text":"<p>             Bases: <code>Exception</code></p> <p>Exceptions relating to DNS Labels</p>"},{"location":"reference/dnslib/lex/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> lex","text":""},{"location":"reference/dnslib/lex/#dnslib.lex","title":"dnslib.lex","text":""},{"location":"reference/dnslib/lex/#dnslib.lex.Lexer","title":"Lexer","text":"<pre><code>Lexer(f, debug=False)\n</code></pre> <p>Simple Lexer base class. Provides basic lexer framework and helper functionality (read/peek/pushback etc)</p> <p>Each state is implemented using a method (lexXXXX) which should match a single token and return a (token,lexYYYY) tuple, with lexYYYY representing the next state. If token is None this is not emitted and if lexYYYY is None or the lexer reaches the end of the input stream the lexer exits.</p> <p>The 'parse' method returns a generator that will return tokens (the class also acts as an iterator)</p> <p>The default start state is 'lexStart'</p> <p>Input can either be a string/bytes or file object.</p> <p>The approach is based loosely on Rob Pike's Go lexer presentation (using generators rather than channels).</p> <pre><code>&gt;&gt;&gt; p = Lexer(\"a bcd efgh\")\n&gt;&gt;&gt; p.read()\n'a'\n&gt;&gt;&gt; p.read()\n' '\n&gt;&gt;&gt; p.peek(3)\n'bcd'\n&gt;&gt;&gt; p.read(5)\n'bcd e'\n&gt;&gt;&gt; p.pushback('e')\n&gt;&gt;&gt; p.read(4)\n'efgh'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>f</code> <p>???</p> required <code>debug</code> <p>???</p> <code>False</code>"},{"location":"reference/dnslib/lex/#dnslib.lex.Lexer.lexStart","title":"lexStart","text":"<pre><code>lexStart()\n</code></pre> <p>LexStart</p>"},{"location":"reference/dnslib/lex/#dnslib.lex.Lexer.next_token","title":"next_token","text":"<pre><code>next_token()\n</code></pre> <p>next_token</p>"},{"location":"reference/dnslib/lex/#dnslib.lex.Lexer.parse","title":"parse","text":"<pre><code>parse()\n</code></pre> <p>parse</p>"},{"location":"reference/dnslib/lex/#dnslib.lex.Lexer.peek","title":"peek","text":"<pre><code>peek(n=1)\n</code></pre> <p>peek Args:     n: ???</p>"},{"location":"reference/dnslib/lex/#dnslib.lex.Lexer.pushback","title":"pushback","text":"<pre><code>pushback(s)\n</code></pre> <p>pushback</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <p>???</p> required"},{"location":"reference/dnslib/lex/#dnslib.lex.Lexer.read","title":"read","text":"<pre><code>read(n=1)\n</code></pre> <p>read</p>"},{"location":"reference/dnslib/lex/#dnslib.lex.Lexer.readescaped","title":"readescaped","text":"<pre><code>readescaped()\n</code></pre> <p>readescaped</p>"},{"location":"reference/dnslib/lex/#dnslib.lex.RandomLexer","title":"RandomLexer","text":"<pre><code>RandomLexer(f, debug=False)\n</code></pre> <p>             Bases: <code>Lexer</code></p> <p>Test lexing from infinite stream.</p> <p>Extract strings of letters/numbers from /dev/urandom</p> <p>import itertools,sys if sys.version[0] == '2': ...     f = open(\"/dev/urandom\") ... else: ...     f = open(\"/dev/urandom\",encoding=\"ascii\",errors=\"replace\") r = RandomLexer(f) i = iter(r) len(list(itertools.islice(i,10))) 10</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <p>???</p> required <code>debug</code> <p>???</p> <code>False</code>"},{"location":"reference/dnslib/lex/#dnslib.lex.RandomLexer.next_token","title":"next_token","text":"<pre><code>next_token()\n</code></pre> <p>next_token</p>"},{"location":"reference/dnslib/lex/#dnslib.lex.RandomLexer.parse","title":"parse","text":"<pre><code>parse()\n</code></pre> <p>parse</p>"},{"location":"reference/dnslib/lex/#dnslib.lex.RandomLexer.peek","title":"peek","text":"<pre><code>peek(n=1)\n</code></pre> <p>peek Args:     n: ???</p>"},{"location":"reference/dnslib/lex/#dnslib.lex.RandomLexer.pushback","title":"pushback","text":"<pre><code>pushback(s)\n</code></pre> <p>pushback</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <p>???</p> required"},{"location":"reference/dnslib/lex/#dnslib.lex.RandomLexer.read","title":"read","text":"<pre><code>read(n=1)\n</code></pre> <p>read</p>"},{"location":"reference/dnslib/lex/#dnslib.lex.RandomLexer.readescaped","title":"readescaped","text":"<pre><code>readescaped()\n</code></pre> <p>readescaped</p>"},{"location":"reference/dnslib/lex/#dnslib.lex.WordLexer","title":"WordLexer","text":"<pre><code>WordLexer(f, debug=False)\n</code></pre> <p>             Bases: <code>Lexer</code></p> <p>Example lexer which will split input stream into words (respecting quotes)</p> <p>To emit SPACE tokens: self.spacetok = ('SPACE',None) To emit NL tokens: self.nltok = ('NL',None)</p> <p>l = WordLexer(r'abc \"def@=. ghi\" jkl') list(l) [('ATOM', 'abc'), ('ATOM', 'def@=. ghi'), ('ATOM', 'jkl')] l = WordLexer(r\"1 '2 3 4' 5\") list(l) [('ATOM', '1'), ('ATOM', '2 3 4'), ('ATOM', '5')] l = WordLexer(\"abc# a comment\") list(l) [('ATOM', 'abc'), ('COMMENT', 'a comment')]</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <p>???</p> required <code>debug</code> <p>???</p> <code>False</code>"},{"location":"reference/dnslib/lex/#dnslib.lex.WordLexer.next_token","title":"next_token","text":"<pre><code>next_token()\n</code></pre> <p>next_token</p>"},{"location":"reference/dnslib/lex/#dnslib.lex.WordLexer.parse","title":"parse","text":"<pre><code>parse()\n</code></pre> <p>parse</p>"},{"location":"reference/dnslib/lex/#dnslib.lex.WordLexer.peek","title":"peek","text":"<pre><code>peek(n=1)\n</code></pre> <p>peek Args:     n: ???</p>"},{"location":"reference/dnslib/lex/#dnslib.lex.WordLexer.pushback","title":"pushback","text":"<pre><code>pushback(s)\n</code></pre> <p>pushback</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <p>???</p> required"},{"location":"reference/dnslib/lex/#dnslib.lex.WordLexer.read","title":"read","text":"<pre><code>read(n=1)\n</code></pre> <p>read</p>"},{"location":"reference/dnslib/lex/#dnslib.lex.WordLexer.readescaped","title":"readescaped","text":"<pre><code>readescaped()\n</code></pre> <p>readescaped</p>"},{"location":"reference/dnslib/ranges/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> ranges","text":""},{"location":"reference/dnslib/ranges/#dnslib.ranges","title":"dnslib.ranges","text":"<p>Wrapper around property builtin to restrict attribute to defined integer value range (throws ValueError).</p> <p>Intended to ensure that values packed with struct are in the correct range</p> <pre><code>&gt;&gt;&gt; class T(object):\n...     a = range_property('a',-100,100)\n...     b = B('b')\n...     c = H('c')\n...     d = I('d')\n...     e = instance_property('e',(int,bool))\n&gt;&gt;&gt; t = T()\n&gt;&gt;&gt; for i in [0,100,-100]:\n...     t.a = i\n...     assert t.a == i\n&gt;&gt;&gt; t.a = 101\nTraceback (most recent call last):\n...\nValueError: Attribute 'a' must be between -100-100 [101]\n&gt;&gt;&gt; t.a = -101\nTraceback (most recent call last):\n...\nValueError: Attribute 'a' must be between -100-100 [-101]\n&gt;&gt;&gt; t.a = 'blah'\nTraceback (most recent call last):\n...\nValueError: Attribute 'a' must be between -100-100 [blah]\n&gt;&gt;&gt; t.e = 999\n&gt;&gt;&gt; t.e = False\n&gt;&gt;&gt; t.e = None\nTraceback (most recent call last):\n...\nValueError: Attribute 'e' must be instance of ...\n\n&gt;&gt;&gt; check_range(\"test\",123,0,255)\n&gt;&gt;&gt; check_range(\"test\",999,0,255)\nTraceback (most recent call last):\n...\nValueError: Attribute 'test' must be between 0-255 [999]\n\n&gt;&gt;&gt; check_instance(\"test\",123,int)\n&gt;&gt;&gt; check_instance(\"test\",\"xxx\",int)\nTraceback (most recent call last):\n...\nValueError: Attribute 'test' must be instance of ...\n</code></pre>"},{"location":"reference/dnslib/ranges/#dnslib.ranges.B","title":"B","text":"<pre><code>B(attr: str)\n</code></pre> <p>Create new Unsigned Byte (8 bit) property</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>name of property attribute</p> required"},{"location":"reference/dnslib/ranges/#dnslib.ranges.H","title":"H","text":"<pre><code>H(attr: str)\n</code></pre> <p>Create new Unsigned Short (16 bit) property</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>name of property attribute</p> required"},{"location":"reference/dnslib/ranges/#dnslib.ranges.I","title":"I","text":"<pre><code>I(attr: str)\n</code></pre> <p>create new Unsigned Long (32 bit) property</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>name of property attribute</p> required"},{"location":"reference/dnslib/ranges/#dnslib.ranges.IP4","title":"IP4","text":"<pre><code>IP4(attr: str)\n</code></pre> <p>Create new IPv4 property</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>name of property attribute</p> required"},{"location":"reference/dnslib/ranges/#dnslib.ranges.IP6","title":"IP6","text":"<pre><code>IP6(attr: str)\n</code></pre> <p>Create new IPv6 property</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>name of property attribute</p> required"},{"location":"reference/dnslib/server/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> server","text":""},{"location":"reference/dnslib/server/#dnslib.server","title":"dnslib.server","text":"<p>DNS server framework - intended to simplify creation of custom resolvers.</p> <p>Comprises the following components:</p> <pre><code>DNSServer   - socketserver wrapper (in most cases you should just\n              need to pass this an appropriate resolver instance\n              and start in either foreground/background)\n\nDNSHandler  - handler instantiated by DNSServer to handle requests\n              The 'handle' method deals with the sending/receiving\n              packets (handling TCP length prefix) and delegates\n              the protocol handling to 'get_reply'. This decodes\n              packet, hands off a DNSRecord to the Resolver instance,\n              and encodes the returned DNSRecord.\n\n              In most cases you dont need to change DNSHandler unless\n              you need to get hold of the raw protocol data in the\n              Resolver\n\nDNSLogger   - The class provides a default set of logging functions for\n              the various stages of the request handled by a DNSServer\n              instance which are enabled/disabled by flags in the 'log'\n              class variable.\n\nResolver    - Instance implementing a 'resolve' method that receives\n              the decodes request packet and returns a response.\n\n              To implement a custom resolver in most cases all you need\n              is to implement this interface.\n\n              Note that there is only a single instance of the Resolver\n              so need to be careful about thread-safety and blocking\n\nThe following examples use the server framework:\n\n    fixedresolver.py    - Simple resolver which will respond to all\n                          requests with a fixed response\n    zoneresolver.py     - Resolver which will take a standard zone\n                          file input\n    shellresolver.py    - Example of a dynamic resolver\n    proxy.py            - DNS proxy\n    intercept.py        - Intercepting DNS proxy\n\n```pycon\n&gt;&gt;&gt; resolver = BaseResolver()\n&gt;&gt;&gt; logger = DNSLogger(prefix=False)\n&gt;&gt;&gt; server = DNSServer(resolver,port=8053,address=\"localhost\",logger=logger)\n&gt;&gt;&gt; server.start_thread()\n&gt;&gt;&gt; q = DNSRecord.question(\"abc.def\")\n&gt;&gt;&gt; a = q.send(\"localhost\",8053)\nRequest: [...] (udp) / 'abc.def.' (A)\nReply: [...] (udp) / 'abc.def.' (A) / NXDOMAIN\n&gt;&gt;&gt; print(DNSRecord.parse(a))\n;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NXDOMAIN, id: ...\n;; flags: qr aa rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 0, ADDITIONAL: 0\n;; QUESTION SECTION:\n;abc.def.                       IN      A\n&gt;&gt;&gt; server.stop()\n\n```\n\nDNSLogger accepts custom logging function (logf)\n\n```pycon\n&gt;&gt;&gt; resolver = BaseResolver()\n&gt;&gt;&gt; logger = DNSLogger(prefix=False,logf=lambda s:print(s.upper()))\n&gt;&gt;&gt; server = DNSServer(resolver,port=8054,address=\"localhost\",logger=logger)\n&gt;&gt;&gt; server.start_thread()\n&gt;&gt;&gt; q = DNSRecord.question(\"abc.def\")\n&gt;&gt;&gt; a = q.send(\"localhost\",8054)\nREQUEST: [...] (UDP) / 'ABC.DEF.' (A)\nREPLY: [...] (UDP) / 'ABC.DEF.' (A) / NXDOMAIN\n&gt;&gt;&gt; print(DNSRecord.parse(a))\n;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NXDOMAIN, id: ...\n;; flags: qr aa rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 0, ADDITIONAL: 0\n;; QUESTION SECTION:\n;abc.def.                       IN      A\n&gt;&gt;&gt; server.stop()\n\n&gt;&gt;&gt; class TestResolver:\n...     def resolve(self,request,handler):\n...         reply = request.reply()\n...         reply.add_answer(*RR.fromZone(\"abc.def. 60 A 1.2.3.4\"))\n...         return reply\n&gt;&gt;&gt; resolver = TestResolver()\n&gt;&gt;&gt; logger = DNSLogger(prefix=False)\n&gt;&gt;&gt; server = DNSServer(resolver,port=8055,address=\"localhost\",logger=logger,tcp=True)\n&gt;&gt;&gt; server.start_thread()\n&gt;&gt;&gt; a = q.send(\"localhost\",8055,tcp=True)\nRequest: [...] (tcp) / 'abc.def.' (A)\nReply: [...] (tcp) / 'abc.def.' (A) / RRs: A\n&gt;&gt;&gt; print(DNSRecord.parse(a))\n;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: ...\n;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0\n;; QUESTION SECTION:\n;abc.def.                       IN      A\n;; ANSWER SECTION:\nabc.def.                60      IN      A       1.2.3.4\n&gt;&gt;&gt; server.stop()\n\n```\n</code></pre>"},{"location":"reference/dnslib/server/#dnslib.server.BaseResolver","title":"BaseResolver","text":"<p>Base resolver implementation.</p> <p>Provides 'resolve' method which is called by DNSHandler with the decode request (DNSRecord instance) and returns a DNSRecord instance as reply.</p> <p>In most cases you should be able to create a custom resolver by just replacing the resolve method with appropriate resolver code for application (see fixedresolver/zoneresolver/shellresolver for examples)</p> <p>Note that a single instance is used by all DNSHandler instances so need to consider blocking &amp; thread safety.</p>"},{"location":"reference/dnslib/server/#dnslib.server.BaseResolver.resolve","title":"resolve","text":"<pre><code>resolve(request, handler)\n</code></pre> <p>Example resolver - respond to all requests with NXDOMAIN</p>"},{"location":"reference/dnslib/server/#dnslib.server.DNSHandler","title":"DNSHandler","text":"<p>             Bases: <code>BaseRequestHandler</code></p> <p>Handler for socketserver.</p> <p>Transparently handles both TCP/UDP requests (TCP requests have length prepended) and hands off lookup to resolver instance specified in .resolver"},{"location":"reference/dnslib/server/#dnslib.server.DNSHandler.get_reply","title":"get_reply","text":"<pre><code>get_reply(data)\n</code></pre> <p>get_reply</p>"},{"location":"reference/dnslib/server/#dnslib.server.DNSHandler.handle","title":"handle","text":"<pre><code>handle()\n</code></pre> <p>handle</p>"},{"location":"reference/dnslib/server/#dnslib.server.DNSLogger","title":"DNSLogger","text":"<pre><code>DNSLogger(log='', prefix=True, logf=None)\n</code></pre> <p>The class provides a default set of logging functions for the various stages of the request handled by a DNSServer instance which are enabled/disabled by flags in the 'log' class variable.</p> <p>To customise logging create an object which implements the DNSLogger interface and pass instance to DNSServer.</p> <p>The methods which the logger instance must implement are:</p> <pre><code>log_recv          - Raw packet received\nlog_send          - Raw packet sent\nlog_request       - DNS Request\nlog_reply         - DNS Response\nlog_truncated     - Truncated\nlog_error         - Decoding error\nlog_data          - Dump full request/response\n</code></pre> <p>A custom logging function can be passed to the constructor via the <code>logf</code> parameter (defaults to print)</p> <p>Selectively enable log hooks depending on log argument (comma separated list of hooks to enable/disable)</p> <ul> <li>If empty enable default log hooks</li> <li>If entry starts with '+' (eg. +send,+recv) enable hook</li> <li>If entry starts with '-' (eg. -data) disable hook</li> <li>If entry doesn't start with +/- replace defaults</li> </ul> <p>Prefix argument enables/disables log prefix</p> <p>Logf argument sets log print function (defaults to print)</p>"},{"location":"reference/dnslib/server/#dnslib.server.DNSServer","title":"DNSServer","text":"<pre><code>DNSServer(\n    resolver,\n    address=\"\",\n    port=53,\n    tcp=False,\n    logger=None,\n    handler=DNSHandler,\n    server=None,\n)\n</code></pre> <p>Convenience wrapper for socketserver instance allowing either UDP/TCP server to be started in blocking more or as a background thread.</p> <p>Processing is delegated to custom resolver (instance) and optionally custom logger (instance), handler (class), and server (class)</p> <p>In most cases only a custom resolver instance is required (and possibly logger)</p> <p>resolver:   resolver instance address:    listen address (default: \"\") port:       listen port (default: 53) tcp:        UDP (false) / TCP (true) (default: False) logger:     logger instance (default: DNSLogger) handler:    handler class (default: DNSHandler) server:     socketserver class (default: UDPServer/TCPServer)</p>"},{"location":"reference/dnslib/test_decode/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> test_decode","text":""},{"location":"reference/dnslib/test_decode/#dnslib.test_decode","title":"dnslib.test_decode","text":"<p>Test dnslib packet encoding/decoding</p> <p>Reads test files from dnslib/test (by default) containing dump of DNS exchange (packet dump &amp; parse output) and test round-trip parsing - specifically:</p> <pre><code>- Parse packet data and zone format data and compare\n- Repack parsed packet data and compare with original\n</code></pre> <p>This should test the 'parse', 'fromZone' and 'pack' methods of the associated record types.</p> <p>The original parsed output is created using dnslib by default so systematic encode/decode errors will not be found. By default the test data is checked against 'dig' to ensure that it is correct when generated using the --new option.</p> <p>By default the module runs in 'unittest' mode (and supports unittest --verbose/--failfast options)</p> <p>The module can also be run in interactive mode (--interactive) and inspect failed tests (--debug)</p> <p>New test data files can be automatically created using the:</p> <pre><code>--new &lt;domain&gt; &lt;type&gt;\n</code></pre> <p>option. The data is checked against dig output and an error raised if this does not match. This is effectively the same as running:</p> <pre><code>python -m dnslib.client --query --hex --dig &lt;domain&gt; &lt;type&gt;\n</code></pre> <p>It is possible to manually generate test data files using dnslib.client even if the dig data doesn't match (this is usually due to an unsupported RDATA type which dnslib will output in hex rather then parsing contents). The roundtrip tests will still work in this case (the unknown RDATA is handled as an opaque blob).</p> <p>In some cases the tests will fail as a result of the zone file parser being more fragile than the packet parser (especially with broken data)</p> <p>Note - unittests are dynamically generated from the test directory contents (matched against the --glob parameter)</p>"},{"location":"reference/dnslib/servers/","title":"Index","text":""},{"location":"reference/dnslib/servers/#dnslib.servers","title":"dnslib.servers","text":""},{"location":"reference/dnslib/servers/fixedresolver/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> fixedresolver","text":""},{"location":"reference/dnslib/servers/fixedresolver/#dnslib.servers.fixedresolver","title":"dnslib.servers.fixedresolver","text":"<p>FixedResolver - example resolver which responds with fixed response                 to all requests</p>"},{"location":"reference/dnslib/servers/fixedresolver/#dnslib.servers.fixedresolver.FixedResolver","title":"FixedResolver","text":"<pre><code>FixedResolver(zone)\n</code></pre> <p>             Bases: <code>BaseResolver</code></p> <p>Respond with fixed response to all requests</p>"},{"location":"reference/dnslib/servers/intercept/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> intercept","text":""},{"location":"reference/dnslib/servers/intercept/#dnslib.servers.intercept","title":"dnslib.servers.intercept","text":"<p>InterceptResolver - proxy requests to upstream server                     (optionally intercepting)</p>"},{"location":"reference/dnslib/servers/intercept/#dnslib.servers.intercept.InterceptResolver","title":"InterceptResolver","text":"<pre><code>InterceptResolver(\n    address,\n    port,\n    ttl,\n    intercept,\n    skip,\n    nxdomain,\n    forward,\n    all_qtypes,\n    timeout=0,\n)\n</code></pre> <p>             Bases: <code>BaseResolver</code></p> <p>Intercepting resolver</p> <p>Proxy requests to upstream server optionally intercepting requests matching local records</p> <p>address/port    - upstream server ttl             - default ttl for intercept records intercept       - list of wildcard RRs to respond to (zone format) skip            - list of wildcard labels to skip nxdomain        - list of wildcard labels to return NXDOMAIN forward         - list of wildcard labels to forward all_qtypes      - intercept all qtypes if qname matches. timeout         - timeout for upstream server(s)</p>"},{"location":"reference/dnslib/servers/proxy/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> proxy","text":""},{"location":"reference/dnslib/servers/proxy/#dnslib.servers.proxy","title":"dnslib.servers.proxy","text":""},{"location":"reference/dnslib/servers/proxy/#dnslib.servers.proxy.PassthroughDNSHandler","title":"PassthroughDNSHandler","text":"<p>             Bases: <code>DNSHandler</code></p> <p>Modify DNSHandler logic (get_reply method) to send directly to upstream DNS server rather then decoding/encoding packet and passing to Resolver (The request/response packets are still parsed and logged but this is not inline)</p>"},{"location":"reference/dnslib/servers/proxy/#dnslib.servers.proxy.PassthroughDNSHandler.handle","title":"handle","text":"<pre><code>handle()\n</code></pre> <p>handle</p>"},{"location":"reference/dnslib/servers/proxy/#dnslib.servers.proxy.ProxyResolver","title":"ProxyResolver","text":"<pre><code>ProxyResolver(address, port, timeout=0, strip_aaaa=False)\n</code></pre> <p>             Bases: <code>BaseResolver</code></p> <p>Proxy resolver - passes all requests to upstream DNS server and returns response</p> <p>Note that the request/response will be each be decoded/re-encoded twice:</p> <p>a) Request packet received by DNSHandler and parsed into DNSRecord b) DNSRecord passed to ProxyResolver, serialised back into packet    and sent to upstream DNS server c) Upstream DNS server returns response packet which is parsed into    DNSRecord d) ProxyResolver returns DNSRecord to DNSHandler which re-serialises    this into packet and returns to client</p> <p>In practice this is actually fairly useful for testing but for a 'real' transparent proxy option the DNSHandler logic needs to be modified (see PassthroughDNSHandler)</p>"},{"location":"reference/dnslib/servers/proxy/#dnslib.servers.proxy.send_tcp","title":"send_tcp","text":"<pre><code>send_tcp(data, host, port)\n</code></pre> <p>Helper function to send/receive DNS TCP request (in/out packets will have prepended TCP length header)</p>"},{"location":"reference/dnslib/servers/proxy/#dnslib.servers.proxy.send_udp","title":"send_udp","text":"<pre><code>send_udp(data, host, port)\n</code></pre> <p>Helper function to send/receive DNS UDP request</p>"},{"location":"reference/dnslib/servers/shellresolver/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> shellresolver","text":""},{"location":"reference/dnslib/servers/shellresolver/#dnslib.servers.shellresolver","title":"dnslib.servers.shellresolver","text":""},{"location":"reference/dnslib/servers/shellresolver/#dnslib.servers.shellresolver.ShellResolver","title":"ShellResolver","text":"<pre><code>ShellResolver(routes, origin, ttl)\n</code></pre> <p>             Bases: <code>BaseResolver</code></p> <p>Example dynamic resolver. Maps DNS labels to shell commands and returns result as TXT record (Note: No context is passed to the shell command)</p> <p>Shell commands are passed in a a list in : format - eg: <pre><code>[ 'uptime.abc.com.:uptime', 'ls:ls' ]\n</code></pre> <p>Would respond to requests to 'uptime.abc.com.' with the output of the 'uptime' command.</p> <p>For non-absolute labels the 'origin' parameter is prepended</p>"},{"location":"reference/dnslib/servers/zoneresolver/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> zoneresolver","text":""},{"location":"reference/dnslib/servers/zoneresolver/#dnslib.servers.zoneresolver","title":"dnslib.servers.zoneresolver","text":""},{"location":"reference/dnslib/servers/zoneresolver/#dnslib.servers.zoneresolver.ZoneResolver","title":"ZoneResolver","text":"<pre><code>ZoneResolver(zone, glob=False)\n</code></pre> <p>             Bases: <code>BaseResolver</code></p> <p>Simple fixed zone file resolver.</p> <p>Initialise resolver from zone file. Stores RRs as a list of (label,type,rr) tuples If 'glob' is True use glob match against zone file</p>"},{"location":"reference/dnslib/servers/zoneresolver/#dnslib.servers.zoneresolver.ZoneResolver.resolve","title":"resolve","text":"<pre><code>resolve(request, handler)\n</code></pre> <p>Respond to DNS request - parameters are request packet &amp; handler. Method is expected to return DNS response</p>"}]}